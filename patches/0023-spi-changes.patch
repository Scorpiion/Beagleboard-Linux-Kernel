Index: primus-kernel/arch/arm/mach-davinci/Makefile
===================================================================
--- primus-kernel.orig/arch/arm/mach-davinci/Makefile
+++ primus-kernel/arch/arm/mach-davinci/Makefile
@@ -25,3 +25,4 @@ obj-$(CONFIG_MACH_DAVINCI_DM355_EVM)	+= 
 obj-$(CONFIG_MACH_SFFSDR)		+= board-sffsdr.o
 obj-$(CONFIG_ARCH_OMAPL1x7)		+= soc-omapl1x7.o
 obj-$(CONFIG_MACH_OMAPL1X7_EVM)		+= board-omapl1x7-evm.o
+obj-$(CONFIG_SPI_DAVINCI)		+= spi.o
Index: primus-kernel/arch/arm/mach-davinci/spi.c
===================================================================
--- /dev/null
+++ primus-kernel/arch/arm/mach-davinci/spi.c
@@ -0,0 +1,296 @@
+/*
+ * TI DA8xx EVM SPI platform
+ *
+ * Copyright (C) 2008 Monta Vista Software Inc. <source@mvista.com>
+ *
+ * Based on: arch/arm/mach-davinci/davinci_spi_platform.c
+ * Copyright (C) 2007 Texas Instruments.
+ * Copyright (C) 2007 Monta Vista Software Inc.
+ *
+ * ----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * ----------------------------------------------------------------------------
+ *
+ * This file came directly from spi_platform_init.c.  This file has been
+ * generalized to all DaVinci variants.  This file should replace
+ * spi_platform_init.c
+ *
+ */
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/resource.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/davinci_spi.h>
+#include <linux/spi/flash.h>
+#include <linux/device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/platform_device.h>
+#include <linux/spi/davinci_spi_master.h>
+#include <linux/spi/at25xxA_eeprom.h>
+#include <linux/spi/mtd_spi_flash.h>
+
+#include <mach/cpu.h>
+#include <mach/mux.h>
+
+static struct davinci_spi_platform_data da8xx_spi_pdata0 = {
+	.version = DAVINCI_SPI_VERSION_2,
+	.num_chipselect = 1,
+	.clk_name = "SPI0CLK",
+};
+
+static struct resource da8xx_spi_resources0[] = {
+	[0] = {
+		.start = 0x01C41000,
+		.end = 0x01C41000 + 0xfff,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_OMAPL1X7_SPINT0,
+		.end = IRQ_OMAPL1X7_SPINT0,
+		.flags = IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start = 14,
+		.end = 14,
+		.flags = IORESOURCE_DMA | IORESOURCE_DMA_RX_CHAN,
+	},
+	[3] = {
+		.start = 15,
+		.end = 15,
+		.flags = IORESOURCE_DMA | IORESOURCE_DMA_TX_CHAN,
+	},
+	[4] = {
+		.start = 1,
+		.end = 1,
+		.flags = IORESOURCE_DMA | IORESOURCE_DMA_EVENT_Q,
+	},
+};
+
+static struct platform_device da8xx_spi_pdev0 = {
+	.name = "dm_spi",
+	.id = 0,
+	.resource = da8xx_spi_resources0,
+	.num_resources = ARRAY_SIZE(da8xx_spi_resources0),
+	.dev = {
+		.platform_data = &da8xx_spi_pdata0,
+	},
+};
+
+static u8 da8xx_spi1_chip_sel[] = {
+	DAVINCI_SPI_INTERN_CS, DAVINCI_SPI_INTERN_CS, 58,
+};
+
+static struct davinci_spi_platform_data da8xx_spi_pdata1 = {
+	.version = DAVINCI_SPI_VERSION_2,
+	.num_chipselect = 3,
+	.clk_name = "SPI1CLK",
+	.chip_sel = da8xx_spi1_chip_sel,
+};
+
+static struct resource da8xx_spi_resources1[] = {
+	[0] = {
+		.start = 0x01E12000,
+		.end = 0x01E12000 + 0xfff,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_OMAPL1X7_SPINT1,
+		.end = IRQ_OMAPL1X7_SPINT1,
+		.flags = IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start = 18,
+		.end = 18,
+		.flags = IORESOURCE_DMA | IORESOURCE_DMA_RX_CHAN,
+	},
+	[3] = {
+		.start = 19,
+		.end = 19,
+		.flags = IORESOURCE_DMA | IORESOURCE_DMA_TX_CHAN,
+	},
+	[4] = {
+		.start = 1,
+		.end = 1,
+		.flags = IORESOURCE_DMA | IORESOURCE_DMA_EVENT_Q,
+	},
+};
+
+static struct platform_device da8xx_spi_pdev1 = {
+	.name = "dm_spi",
+	.id = 1,
+	.resource = da8xx_spi_resources1,
+	.num_resources = ARRAY_SIZE(da8xx_spi_resources1),
+	.dev = {
+		.platform_data = &da8xx_spi_pdata1,
+	},
+};
+
+#if defined(CONFIG_MTD_SPI_FLASH) || defined(CONFIG_MTD_SPI_FLASH_MODULE)
+static struct mtd_partition flash_partitions[] = {
+	[0] = {
+		.name = "U-Boot",
+		.offset = 0,
+		.size = SZ_128K,
+		.mask_flags = MTD_WRITEABLE,
+	},
+	[1] = {
+		.name = "U-Boot Environment",
+		.offset = MTDPART_OFS_APPEND,
+		.size = SZ_16K,
+		.mask_flags = MTD_WRITEABLE,
+	},
+	[2] = {
+		.name = "Linux",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL,
+		.mask_flags = 0,
+	},
+};
+
+struct davinci_spi_config_t w25x64_spi_cfg = {
+	.wdelay		= 0,
+	.odd_parity	= 0,
+	.parity_enable	= 0,
+	.wait_enable	= 0,
+	.lsb_first	= 0,
+	.timer_disable	= 0,
+	.clk_high	= 0,
+	.phase_in	= 1,
+	.clk_internal	= 1,
+	.loop_back	= 0,
+	.cs_hold	= 1,
+	.intr_level	= 0,
+	.pin_op_modes	= SPI_OPMODE_SPISCS_4PIN,
+#ifndef CONFIG_SPI_INTERRUPT
+	.poll_mode	= 1,
+#endif
+};
+
+struct mtd_spi_flash_info w25x64_spi_flash = {
+	.name = "Windbond spi nand flash",
+	.chip_sel = SCS0_SELECT,
+	.parts = flash_partitions,
+	.nr_parts = ARRAY_SIZE(flash_partitions),
+};
+#endif
+
+static struct spi_board_info da8xx_spi_board_info0[] = {
+#if defined(CONFIG_MTD_SPI_FLASH) || defined(CONFIG_MTD_SPI_FLASH_MODULE)
+	[0] = {
+		.modalias = MTD_SPI_FLASH_NAME,
+		.platform_data = &w25x64_spi_flash,
+		.controller_data = &w25x64_spi_cfg,
+		.mode = SPI_MODE_0,
+		.max_speed_hz = 25000000,	/* max sample rate at 3V */
+		.bus_num = 0,
+		.chip_select = 0,
+	},
+#endif
+};
+
+static int ak4588_place_holder;
+
+struct davinci_spi_config_t ak4588_spi_cfg = {
+	.wdelay		= 0,
+	.odd_parity	= 0,
+	.parity_enable	= 0,
+	.wait_enable	= 0,
+	.lsb_first	= 0,
+	.timer_disable	= 0,
+	.clk_high	= 0,
+	.phase_in	= 1,
+	.clk_internal	= 1,
+	.loop_back	= 0,
+	.cs_hold	= 1,
+	.intr_level	= 0,
+	.pin_op_modes	= SPI_OPMODE_SPISCS_4PIN,
+#ifndef CONFIG_SPI_INTERRUPT
+	.poll_mode	= 1,
+#endif
+};
+
+static struct spi_board_info da8xx_spi_board_info1[] = {
+	[0] = {
+		.modalias = "AK4588 audio codec",
+		.platform_data = &ak4588_place_holder,
+		.controller_data = &ak4588_spi_cfg,
+		.mode = SPI_MODE_0,
+		.max_speed_hz = 2000000,	/* max sample rate at 3V */
+		.bus_num = 1,
+		.chip_select = 2,
+	},
+};
+
+/*
+ * This function registers the SPI master platform device and the SPI slave
+ * devices with the SPI bus.
+ */
+static int __init da8xx_spi_register(struct platform_device *pdev,
+				     struct spi_board_info *bi,
+				     unsigned int bi_size)
+{
+	int ret = platform_device_register(pdev);
+
+	if (ret)
+		return ret;
+
+	return spi_register_board_info(bi, bi_size);
+
+}
+
+static int __init da8xx_spi_board_init(void)
+{
+	int ret = da8xx_spi_register(&da8xx_spi_pdev0, da8xx_spi_board_info0,
+				     ARRAY_SIZE(da8xx_spi_board_info0));
+
+	if (ret)
+		return ret;
+	else {
+		davinci_cfg_reg(OMAPL1X7_SPI0_SOMI_0);
+		davinci_cfg_reg(OMAPL1X7_SPI0_SIMO_0);
+		davinci_cfg_reg(OMAPL1X7_SPI0_CLK);
+		davinci_cfg_reg(OMAPL1X7_NSPI0_ENA);
+		davinci_cfg_reg(OMAPL1X7_NSPI0_SCS_0);
+	}
+
+	ret = da8xx_spi_register(&da8xx_spi_pdev1, da8xx_spi_board_info1,
+				  ARRAY_SIZE(da8xx_spi_board_info1));
+
+	if (ret)
+		return ret;
+	else {
+		davinci_cfg_reg(OMAPL1X7_SPI1_SOMI_0);
+		davinci_cfg_reg(OMAPL1X7_SPI1_SIMO_0);
+		davinci_cfg_reg(OMAPL1X7_SPI1_CLK);
+		davinci_cfg_reg(OMAPL1X7_NSPI1_ENA);
+		davinci_cfg_reg(OMAPL1X7_GPIO3_10);
+	}
+
+	return ret;
+}
+
+static void __exit da8xx_spi_board_exit(void)
+{
+	/* nothing to be done */
+}
+
+module_init(da8xx_spi_board_init);
+module_exit(da8xx_spi_board_exit);
Index: primus-kernel/drivers/mtd/devices/Kconfig
===================================================================
--- primus-kernel.orig/drivers/mtd/devices/Kconfig
+++ primus-kernel/drivers/mtd/devices/Kconfig
@@ -97,6 +97,15 @@ config MTD_M25P80
 	  if you want to specify device partitioning or to use a device which
 	  doesn't support the JEDEC ID instruction.
 
+config MTD_SPI_FLASH
+	tristate "Support for Windbond W25XXX Flash"
+	depends on MTD && SPI_MASTER
+	help
+	  Supports Windbond SPI FLASH.  The SPI FLASH operations are similar
+	  across various devices.  The goal is to have something that is
+	  generic enough to handle SPI FLASH from various vendors.  A goal
+	  for example is to merge the ST M25 driver into this driver.
+
 config M25PXX_USE_FAST_READ
 	bool "Use FAST_READ OPCode allowing SPI CLK <= 50MHz"
 	depends on MTD_M25P80
Index: primus-kernel/drivers/mtd/devices/at25xxA_eeprom.c
===================================================================
--- /dev/null
+++ primus-kernel/drivers/mtd/devices/at25xxA_eeprom.c
@@ -0,0 +1,267 @@
+/*
+ * Davinci SPI-EEPROM client driver
+ *
+ * Author: Steve Chen <schen@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/spi/spi.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <linux/uaccess.h>
+
+#include <linux/spi/at25xxA_eeprom.h>
+#include <linux/spi/davinci_spi_master.h>
+
+/*
+ *  Utilities functions
+ */
+static int spi_generic_eeprom_read(struct mtd_info *mtd, loff_t from,
+				   size_t count, size_t *retlen, u_char *buf)
+{
+	u8 *tx_ptr, *rx_ptr;
+	int rx_cnt;
+	unsigned int addr;
+	unsigned long flags;
+	struct spi_transfer x[2];
+	struct spi_message msg;
+	struct davinci_eeprom_info *priv_dat = mtd->priv;
+
+	addr = (u16) from;
+	*retlen = 0;
+	if (addr > priv_dat->eeprom_size)
+		return -EINVAL;
+
+	if (count > priv_dat->eeprom_size)
+		return -EINVAL;
+
+	if ((addr + count) > priv_dat->eeprom_size)
+		return -EINVAL;
+
+	memset(x, 0, sizeof x);
+	down(&priv_dat->lock);
+	x[0].tx_buf = tx_ptr = priv_dat->tx_buffer;
+
+	tx_ptr[0] = DAVINCI_EEPROM_READ;
+
+	x[0].len = 3;
+
+	/* Handle data return from EEPROM */
+	x[1].rx_buf = rx_ptr = priv_dat->rx_buffer;
+
+	while (count > 0) {
+		if (likely(count > SPI_BUFFER_SIZE))
+			rx_cnt = SPI_BUFFER_SIZE;
+		else
+			rx_cnt = count;
+
+		spi_message_init(&msg);
+		/* setup read command */
+		tx_ptr[1] = (addr >> 8) & 0xFF;
+		tx_ptr[2] = (addr & 0xFF);
+
+		local_irq_save(flags);
+		spi_message_add_tail(&x[0], &msg);
+
+		/* read the eeprom */
+		x[1].len = rx_cnt;
+		spi_message_add_tail(&x[1], &msg);
+		local_irq_restore(flags);
+
+		spi_sync(priv_dat->spi, &msg);
+
+		/* spi_read(priv_dat->spi, rx_ptr, rx_cnt); */
+		memcpy(buf, rx_ptr, rx_cnt);
+
+		buf += rx_cnt;
+		count -= rx_cnt;
+		addr += rx_cnt;
+		*retlen += rx_cnt;
+	}
+	up(&priv_dat->lock);
+
+	return 0;
+}
+
+static int spi_generic_eeprom_write(struct mtd_info *mtd, loff_t to,
+				    size_t count, size_t *retlen,
+				    const u_char *buf)
+{
+	char *ptr;
+	int status;
+	int tx_cnt;
+	unsigned int addr;
+	struct spi_transfer xfer[2];
+	struct spi_message msg;
+	struct davinci_eeprom_info *priv_dat = mtd->priv;
+	unsigned long flags;
+
+	addr = (u16) (to);
+	*retlen = 0;
+	memset(xfer, 0, sizeof xfer);
+	if (addr > priv_dat->eeprom_size)
+		return -EINVAL;
+
+	if (count > priv_dat->eeprom_size)
+		return -EINVAL;
+
+	if ((addr + count) > priv_dat->eeprom_size)
+		return -EINVAL;
+
+	down(&priv_dat->lock);
+	while (count > 0) {
+		xfer[0].tx_buf = ptr = priv_dat->tx_buffer;
+
+		/* set write enable */
+		ptr[0] = DAVINCI_EEPROM_WREN;
+		spi_write(priv_dat->spi, ptr, 1);
+
+		spi_message_init(&msg);
+
+		/* set the write command */
+		ptr[0] = DAVINCI_EEPROM_WRITE;
+		ptr[1] = (addr >> 8) & 0xFF;
+		ptr[2] = (addr & 0xFF);
+		xfer[0].len = DAVINCI_SPI_TX_CMD_SIZE;
+		local_irq_save(flags);
+		spi_message_add_tail(&xfer[0], &msg);
+
+		/* figure out the max transfer within a page */
+		tx_cnt = priv_dat->page_size - (addr & priv_dat->page_mask);
+
+		if (count < tx_cnt)
+			tx_cnt = count;
+
+		ptr = &priv_dat->tx_buffer[DAVINCI_SPI_TX_CMD_SIZE];
+		xfer[1].tx_buf = ptr;
+		xfer[1].len = tx_cnt;
+		memcpy(ptr, buf, tx_cnt);
+		spi_message_add_tail(&xfer[1], &msg);
+		local_irq_restore(flags);
+		status = spi_sync(priv_dat->spi, &msg);
+
+		count -= tx_cnt;
+		buf += tx_cnt;
+		addr += tx_cnt;
+		*retlen += tx_cnt;
+		/* Some SPI-EEPROM (CSI for example) starts an internal
+		   transfer (from buffer to EEPROM) when WREN is disalbed.
+		   All requrests are ignored until the transfer is completed.
+		   This delay ensure no data is lost */
+		if (priv_dat->commit_delay)
+			mdelay(priv_dat->commit_delay);
+	}
+	up(&priv_dat->lock);
+
+	return (0);
+}
+
+static int spi_eeprom_generic_erase(struct mtd_info *mtd,
+				    struct erase_info *instr)
+{
+	instr->state = MTD_ERASE_DONE;
+	mtd_erase_callback(instr);
+	return 0;
+}
+
+static struct mtd_info davinci_at25;
+
+static int __devinit eeprom_probe(struct spi_device *spi)
+{
+	int ret;
+	static struct mtd_info *mtd;
+	struct davinci_eeprom_info *info;
+
+	mtd = &davinci_at25;
+	memset(mtd, 0, sizeof(struct mtd_info));
+
+	/* are there any id we need to read? */
+	info = spi->dev.platform_data;
+	info->spi = spi;
+	info->spi_data = spi_master_get_devdata(spi->master);
+	init_MUTEX(&info->lock);
+
+	mtd->priv = info;
+	mtd->size = info->eeprom_size;
+	mtd->flags = MTD_CAP_RAM;
+	mtd->read = spi_generic_eeprom_read;
+	mtd->write = spi_generic_eeprom_write;
+	mtd->erase = spi_eeprom_generic_erase;
+	mtd->type = MTD_RAM;
+	mtd->name = "spi_eeprom";
+	mtd->erasesize = 0x10;
+	mtd->writesize = 1;
+
+#ifdef CONFIG_MTD_PARTITIONS
+	if (info->nr_parts)
+		ret = add_mtd_partitions(mtd, info->parts, info->nr_parts);
+	else
+		ret = add_mtd_device(mtd);
+#else
+	ret = add_mtd_device(mtd);
+#endif
+
+	if (ret < 0)
+		pr_info("at25xxA_spi_eeprom device register failed\n");
+
+	return ret;
+}
+
+static int __devexit eeprom_remove(struct spi_device *spi)
+{
+	int ret;
+	struct mtd_info *mtd;
+	struct davinci_eeprom_info *info;
+
+	mtd = &davinci_at25;
+	info = spi->dev.platform_data;
+
+#ifdef CONFIG_MTD_PARTITIONS
+	if (info->nr_parts)
+		ret = del_mtd_partitions(mtd);
+	else
+		ret = del_mtd_device(mtd);
+#else
+	ret = del_mtd_device(mtd);
+#endif
+
+	return ret;
+}
+
+static struct spi_driver spi_eeprom_driver = {
+	.driver = {
+		   .name = DAVINCI_SPI_EEPROM_NAME,
+		   .bus = &spi_bus_type,
+		   .owner = THIS_MODULE,
+		   },
+	.probe = eeprom_probe,
+	.remove = eeprom_remove,
+};
+
+static int __init spi_eeprom_init(void)
+{
+	return spi_register_driver(&spi_eeprom_driver);
+}
+
+module_init(spi_eeprom_init);
+
+static void __exit spi_eeprom_exit(void)
+{
+	spi_unregister_driver(&spi_eeprom_driver);
+}
+
+module_exit(spi_eeprom_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Steve Chen");
+MODULE_DESCRIPTION("SPI EEPROM driver");
Index: primus-kernel/drivers/mtd/devices/spi_flash.c
===================================================================
--- /dev/null
+++ primus-kernel/drivers/mtd/devices/spi_flash.c
@@ -0,0 +1,408 @@
+/*
+ * SPI FLASH driver
+ *
+ * Author: Steve Chen <schen@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/spi/spi.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <linux/uaccess.h>
+
+#include <linux/spi/mtd_spi_flash.h>
+
+
+void spi_flash_write_enable(struct mtd_info *mtd)
+{
+	char buf;
+	struct mtd_spi_flash_info *priv_dat = mtd->priv;
+
+	/* set write enable */
+	buf = MTD_SPI_FLASH_WREN;
+	spi_write(priv_dat->spi, &buf, 1);
+}
+
+static u8 spi_flash_read_status(struct spi_device *spi)
+{
+	return spi_w8r8(spi, MTD_SPI_FLASH_RDSTAT);
+}
+
+static int spi_flash_wait_complete(struct spi_device *spi)
+{
+	int i;
+
+	/* set a 2 second timeout */
+	for (i = 0; i < 1000; i++) {
+		if (spi_flash_read_status(spi) & SPI_FLASH_STAT_BUSY)
+			msleep(2);
+		else
+			return 0;
+	}
+	printk(KERN_WARNING "SPI FLASH operation timeout\n");
+	return -1;
+}
+
+
+static int spi_flash_read(struct mtd_info *mtd, loff_t from,
+			  size_t count, size_t *retlen, u_char *buf)
+{
+	int rx_cnt;
+	u8 *ptr;
+	unsigned int addr;
+	unsigned long flags;
+	struct spi_transfer x[2];
+	struct spi_message msg;
+	struct mtd_spi_flash_info *priv_dat = mtd->priv;
+
+	addr = (u32) from;
+	*retlen = 0;
+	if ((count <= 0) || ((addr + count) > mtd->size))
+		return -EINVAL;
+
+	memset(x, 0, sizeof x);
+	mutex_lock(&priv_dat->lock);
+	x[0].tx_buf = ptr = priv_dat->tx_buffer;
+	ptr[0] = MTD_SPI_FLASH_FRD;
+	x[0].len = SPI_FLASH_CMD_SIZE;
+
+	/* Handle data return from FLASH */
+	x[1].rx_buf = priv_dat->rx_buffer;
+
+	while (count > 0) {
+		if (likely(count > SPI_FLASH_BUFFER_SIZE))
+			rx_cnt = SPI_FLASH_BUFFER_SIZE;
+		else
+			rx_cnt = count;
+
+		spi_message_init(&msg);
+		/* setup read command */
+		ptr[1] = (addr >> 16) & 0xFF;
+		ptr[2] = (addr >> 8) & 0xFF;
+		ptr[3] = (addr & 0xFF);
+
+		local_irq_save(flags);
+		spi_message_add_tail(&x[0], &msg);
+
+		/* read the device */
+		x[1].len = rx_cnt + 1;
+		spi_message_add_tail(&x[1], &msg);
+		local_irq_restore(flags);
+
+		spi_sync(priv_dat->spi, &msg);
+
+		/* skip over the dummy byte because fast read is used */
+		memcpy(buf, x[1].rx_buf + 1, rx_cnt);
+
+		buf += rx_cnt;
+		count -= rx_cnt;
+		addr += rx_cnt;
+		*retlen += rx_cnt;
+	}
+	mutex_unlock(&priv_dat->lock);
+
+	return 0;
+}
+
+static int spi_flash_write(struct mtd_info *mtd, loff_t to,
+			   size_t count, size_t *retlen,
+			   const u_char *buf)
+{
+	char *ptr;
+	int status;
+	int tx_cnt;
+	int size_limit;
+	unsigned int addr;
+	struct spi_transfer xfer;
+	struct spi_message msg;
+	struct mtd_spi_flash_info *priv_dat = mtd->priv;
+
+	addr = (u32) (to);
+	*retlen = 0;
+	memset(&xfer, 0, sizeof xfer);
+
+	if ((count <= 0) || ((addr + count) > mtd->size))
+		return -EINVAL;
+
+	/* take the smaller of buffer size and page size */
+	/* Want to make buffer size > than page size for better performance */
+	if (priv_dat->page_size <= SPI_FLASH_BUFFER_SIZE)
+		size_limit = priv_dat->page_size;
+	else
+		size_limit = SPI_FLASH_BUFFER_SIZE;
+
+	mutex_lock(&priv_dat->lock);
+	while (count > 0) {
+		spi_flash_write_enable(mtd);
+
+		spi_message_init(&msg);
+		xfer.tx_buf = ptr = priv_dat->tx_buffer;
+
+		/* set the write command */
+		ptr[0] = MTD_SPI_FLASH_WRITE;
+		ptr[1] = (addr >> 16) & 0xFF;
+		ptr[2] = (addr >> 8) & 0xFF;
+		ptr[3] = (addr & 0xFF);
+
+		/* figure out the max data able to transfer */
+		tx_cnt = size_limit - (addr & (priv_dat->page_size - 1));
+		if (count < tx_cnt)
+			tx_cnt = count;
+
+		/* copy over the write data */
+		ptr = &ptr[SPI_FLASH_CMD_SIZE];
+		memcpy(ptr, buf, tx_cnt);
+		xfer.len = SPI_FLASH_CMD_SIZE + tx_cnt;
+
+		spi_message_add_tail(&xfer, &msg);
+		status = spi_sync(priv_dat->spi, &msg);
+
+		count -= tx_cnt;
+		buf += tx_cnt;
+		addr += tx_cnt;
+		*retlen += tx_cnt;
+
+		spi_flash_wait_complete(priv_dat->spi);
+	}
+	mutex_unlock(&priv_dat->lock);
+
+	return (0);
+}
+
+static int spi_flash_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	u8 op_code;
+	char *ptr;
+	struct spi_transfer x;
+	struct spi_message msg;
+	struct mtd_spi_flash_info *priv_dat = mtd->priv;
+
+	/*if (((instr->addr + instr->len) >= mtd->size) ||
+	    ((instr->addr % priv_dat->sector_erase_size) != 0) ||
+	    ((instr->len % priv_dat->sector_erase_size) != 0))
+		return -EINVAL;*/
+
+	memset(&x, 0, sizeof(x));
+	x.tx_buf = ptr = priv_dat->tx_buffer;
+
+	mutex_lock(&priv_dat->lock);
+	while (instr->len > 0) {
+		spi_flash_write_enable(mtd);
+		spi_message_init(&msg);
+		ptr[1] = (u8) ((instr->addr >> 16) & 0xFF);
+		ptr[2] = (u8) ((instr->addr >> 8) & 0xFF);
+		ptr[3] = (u8) (instr->addr & 0xFF);
+		x.len = 4;
+
+		if (instr->len < priv_dat->block_erase_size) {
+			op_code = MTD_SPI_FLASH_SECERA;
+			instr->addr += priv_dat->sector_erase_size;
+			instr->len -= priv_dat->sector_erase_size;
+		} else if (instr->len < mtd->size) {
+			op_code = MTD_SPI_FLASH_BKERA;
+			instr->addr += priv_dat->block_erase_size;
+			instr->len -= priv_dat->block_erase_size;
+		} else {
+			op_code = MTD_SPI_FLASH_CHPERA;
+			instr->len = 0;
+			x.len = 1;
+		}
+		ptr[0] = op_code;
+
+		spi_message_add_tail(&x, &msg);
+		spi_sync(priv_dat->spi, &msg);
+		spi_flash_wait_complete(priv_dat->spi);
+	}
+	mutex_unlock(&priv_dat->lock);
+
+	instr->state = MTD_ERASE_DONE;
+	mtd_erase_callback(instr);
+
+	return 0;
+}
+
+static int spi_flash_read_mfc_id(struct spi_device *spi, char *mfr, char *id)
+{
+	unsigned long flags;
+	char tx_buf[1];
+	char rx_buf[5];
+	struct spi_transfer x[2];
+	struct spi_message msg;
+
+	memset(x, 0, sizeof x);
+	x[0].tx_buf = tx_buf;
+	tx_buf[0] = MTD_SPI_FLASH_MFRID;
+	x[0].len = 1;
+
+	/* Send command to read manufacture and device ID */
+	spi_message_init(&msg);
+	local_irq_save(flags);
+	spi_message_add_tail(&x[0], &msg);
+
+	/* prepare the receive buffer */
+	x[1].rx_buf = rx_buf;
+	x[1].len = 5;
+	spi_message_add_tail(&x[1], &msg);
+	local_irq_restore(flags);
+
+	spi_sync(spi, &msg);
+
+	/*
+	 * Receive buffer format is
+	 * Byte0  Byte1  Byte2  Byte3  Byte4
+	 * dummy  dummy  0x0    MFC_ID DEV_ID
+	 */
+	*mfr = rx_buf[3];
+	*id = rx_buf[4];
+
+	return 0;
+}
+
+static int spi_flash_init_device(struct spi_device *spi, u32 dev_size,
+				u32 page_size, u32 sec_size, u32 blk_size)
+{
+	struct mtd_spi_flash_info *info;
+	static struct mtd_info *mtd;
+	int ret;
+
+	info = spi->dev.platform_data;
+	info->spi = spi;
+	info->spi_data = spi_master_get_devdata(spi->master);
+	info->page_size = page_size;
+	info->sector_erase_size = sec_size;
+	info->block_erase_size = blk_size;
+	mutex_init(&info->lock);
+
+	mtd = &info->mtd;
+	memset(mtd, 0, sizeof(struct mtd_info));
+
+	mtd->priv = info;
+	mtd->size = dev_size;
+	mtd->flags = MTD_CAP_NORFLASH;
+	mtd->name = info->name;
+	mtd->erasesize = sec_size;
+	mtd->writesize = 1;
+
+	mtd->type = MTD_DATAFLASH;
+	mtd->read = spi_flash_read;
+	mtd->write = spi_flash_write;
+	mtd->erase = spi_flash_erase;
+
+#ifdef CONFIG_MTD_PARTITIONS
+	if (info->nr_parts)
+		ret = add_mtd_partitions(mtd, info->parts, info->nr_parts);
+	else
+		ret = add_mtd_device(mtd);
+#else
+	ret = add_mtd_device(mtd);
+#endif
+
+	if (ret < 0)
+		pr_info("SPI FLASH device register failed\n");
+
+	return ret;
+
+}
+
+static int spi_flash_init_winbond(struct spi_device *spi, char id)
+{
+	int ret;
+
+	switch (id) {
+	case SPI_FLASH_W25X16:
+		ret = spi_flash_init_device(spi, 0x200000, 0x100, 0x1000,
+					0x10000);
+		break;
+	case SPI_FLASH_W25X32:
+		ret = spi_flash_init_device(spi, 0x400000, 0x100, 0x1000,
+					0x10000);
+		break;
+	case SPI_FLASH_W25X64:
+		ret = spi_flash_init_device(spi, 0x800000, 0x100, 0x1000,
+					0x10000);
+		break;
+	default:
+		printk(KERN_WARNING "Winbond SPI FLASH %x not supported", id);
+		ret = -1;
+	}
+	return ret;
+}
+
+static int __devinit spi_flash_probe(struct spi_device *spi)
+{
+	char mfr, id;
+	int ret;
+
+	spi_flash_read_mfc_id(spi, &mfr, &id);
+
+	switch (mfr) {
+	case SPI_FLASH_MFR_WINBOND:
+		ret = spi_flash_init_winbond(spi, id);
+		break;
+	default:
+		printk(KERN_WARNING "SPI FLASH Manufacture code %x not "
+			"supported", mfr);
+		ret = -1;
+	}
+	return ret;
+}
+
+static int __devexit spi_flash_remove(struct spi_device *spi)
+{
+	int ret;
+	struct mtd_info *mtd;
+	struct mtd_spi_flash_info *info;
+
+	info = spi->dev.platform_data;
+	mtd = &info->mtd;
+
+#ifdef CONFIG_MTD_PARTITIONS
+	if (info->nr_parts)
+		ret = del_mtd_partitions(mtd);
+	else
+		ret = del_mtd_device(mtd);
+#else
+	ret = del_mtd_device(mtd);
+#endif
+
+	return ret;
+}
+
+static struct spi_driver spi_flash_driver = {
+	.driver = {
+		.name = MTD_SPI_FLASH_NAME,
+		.bus = &spi_bus_type,
+		.owner = THIS_MODULE,
+	},
+	.probe = spi_flash_probe,
+	.remove = spi_flash_remove,
+};
+
+static int __init spi_flash_init(void)
+{
+	return spi_register_driver(&spi_flash_driver);
+}
+
+module_init(spi_flash_init);
+
+static void __exit spi_flash_exit(void)
+{
+	spi_unregister_driver(&spi_flash_driver);
+}
+
+module_exit(spi_flash_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Steve Chen");
+MODULE_DESCRIPTION("SPI FLASH driver");
Index: primus-kernel/drivers/spi/Kconfig
===================================================================
--- primus-kernel.orig/drivers/spi/Kconfig
+++ primus-kernel/drivers/spi/Kconfig
@@ -77,6 +77,23 @@ config SPI_AU1550
 	  This driver can also be built as a module.  If so, the module
 	  will be called au1550_spi.
 
+config SPI_DAVINCI
+	tristate "SPI controller driver for DaVinci SoC"
+	depends on SPI_MASTER && ARCH_DAVINCI
+	select SPI_BITBANG
+	default y
+	help
+	  SPI master controller for DaVinci MibSPI modules.  Currently,
+	  SPI is only officially supported for DM646x, DM355 and DA8xx.
+
+config SPI_DAVINCI_DMA
+	bool "Set DaVinci SPI to DMA mode"
+	depends on SPI_DAVINCI
+	default y
+	help
+	  Select this option to set DaVinci SPI to DMA mode, deselect
+	  to put in PIO mode.
+
 config SPI_BITBANG
 	tristate "Utilities for Bitbanging SPI masters"
 	help
@@ -251,6 +268,12 @@ config SPI_TLE62X0
 #
 # Add new SPI protocol masters in alphabetical order above this line
 #
+config DAVINCI_SPI_EEPROM
+	tristate "DaVinci SPI EEPROM"
+	depends on SPI_DAVINCI
+	default y
+	help
+	  This enables the SPI EEPROM client for TI DaVinci
 
 endif # SPI_MASTER
 
Index: primus-kernel/drivers/spi/Makefile
===================================================================
--- primus-kernel.orig/drivers/spi/Makefile
+++ primus-kernel/drivers/spi/Makefile
@@ -30,6 +30,7 @@ obj-$(CONFIG_SPI_S3C24XX)		+= spi_s3c24x
 obj-$(CONFIG_SPI_TXX9)			+= spi_txx9.o
 obj-$(CONFIG_SPI_XILINX)		+= xilinx_spi.o
 obj-$(CONFIG_SPI_SH_SCI)		+= spi_sh_sci.o
+obj-$(CONFIG_SPI_DAVINCI)		+= davinci_spi_master.o
 # 	... add above this line ...
 
 # SPI protocol drivers (device/link on bus)
Index: primus-kernel/drivers/spi/davinci_spi_master.c
===================================================================
--- /dev/null
+++ primus-kernel/drivers/spi/davinci_spi_master.c
@@ -0,0 +1,1158 @@
+/*
+ * Copyright (C) 2006 Texas Instruments.
+ *
+ * controller driver with Interrupt.
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/platform_device.h>
+
+#include <linux/spi/davinci_spi_master.h>
+#include <linux/dma-mapping.h>
+#include <linux/io.h>
+#include <mach/edma.h>
+#include <mach/cpu.h>
+#include <mach/mux.h>
+#include <mach/gpio.h>
+
+#ifdef CONFIG_SPI_DAVINCI_DMA
+static unsigned use_dma = 1;
+#else
+static unsigned use_dma;
+#endif
+module_param(use_dma, uint, 0644);
+
+static inline void
+davinci_spi_rx_buf_u8(u32 data, struct davinci_spi *davinci_spi)
+{
+	u8 *rx = davinci_spi->rx;
+	*rx++ = (u8)data;
+	davinci_spi->rx = rx;
+}
+
+static inline void
+davinci_spi_rx_buf_u16(u32 data, struct davinci_spi *davinci_spi)
+{
+	u16 *rx = davinci_spi->rx;
+	*rx++ = (u16)data;
+	davinci_spi->rx = rx;
+}
+
+static inline u32
+davinci_spi_tx_buf_u8(struct davinci_spi *davinci_spi)
+{
+	u32 data;
+	const u8 *tx = davinci_spi->tx;
+	data = *tx++;
+	davinci_spi->tx = tx;
+	return data;
+}
+
+static inline u32
+davinci_spi_tx_buf_u16(struct davinci_spi *davinci_spi)
+{
+	u32 data;
+	const u16 *tx = davinci_spi->tx;
+	data = *tx++;
+	davinci_spi->tx = tx;
+	return data;
+}
+
+static inline void set_bits(void __iomem *addr, u32 bits)
+{
+	u32 v = ioread32(addr);
+	v |= bits;
+	iowrite32(v, addr);
+}
+
+static inline void clear_bits(void __iomem *addr, u32 bits)
+{
+	u32 v = ioread32(addr);
+	v &= ~bits;
+	iowrite32(v, addr);
+}
+
+static inline void set_fmt_bits(void __iomem *addr, u32 bits)
+{
+	set_bits(addr + SPIFMT0, bits);
+	set_bits(addr + SPIFMT1, bits);
+	set_bits(addr + SPIFMT2, bits);
+	set_bits(addr + SPIFMT3, bits);
+}
+
+static inline void clear_fmt_bits(void __iomem *addr, u32 bits)
+{
+	clear_bits(addr + SPIFMT0, bits);
+	clear_bits(addr + SPIFMT1, bits);
+	clear_bits(addr + SPIFMT2, bits);
+	clear_bits(addr + SPIFMT3, bits);
+}
+
+static void davinci_spi_set_dma_req(const struct spi_device *spi, int enable)
+{
+	struct davinci_spi *davinci_spi = spi_master_get_devdata(spi->master);
+
+	if (enable)
+		set_bits(davinci_spi->base + SPIINT, SPI_SPIINT_DMA_REQ_EN);
+	else
+		clear_bits(davinci_spi->base + SPIINT, SPI_SPIINT_DMA_REQ_EN);
+}
+
+/*
+ * Interface to control the chip select signal
+ */
+static void davinci_spi_chipselect(struct spi_device *spi, int value)
+{
+	struct davinci_spi *davinci_spi;
+	u32 data1_reg_val = 0;
+	struct davinci_spi_platform_data *pdata;
+	int i;
+
+	davinci_spi = spi_master_get_devdata(spi->master);
+	pdata = davinci_spi->pdata;
+
+	/* board specific chip select logic decides the polarity and cs */
+	/* line for the controller */
+	if (value == BITBANG_CS_INACTIVE) {
+		/* set all chip select high */
+		if (pdata->chip_sel != NULL) {
+			for (i = 0; i < pdata->num_chipselect; i++) {
+				if (pdata->chip_sel[i] != DAVINCI_SPI_INTERN_CS)
+					gpio_set_value(pdata->chip_sel[i], 1);
+			}
+		}
+
+		set_bits(davinci_spi->base + SPIDEF, CS_DEFAULT);
+
+		data1_reg_val |= CS_DEFAULT << SPI_SPIDAT1_CSNR_SHIFT;
+		iowrite32(data1_reg_val, davinci_spi->base + SPIDAT1);
+
+		while (1)
+			if (ioread32(davinci_spi->base + SPIBUF)
+					& SPI_SPIBUF_RXEMPTY_MASK)
+				break;
+	}
+}
+
+/**
+ * davinci_spi_setup_transfer - This functions will determine transfer method
+ * @spi: spi device on which data transfer to be done
+ * @t: spi transfer in which transfer info is filled
+ *
+ * This function determines data transfer method (8/16/32 bit transfer).
+ * It will also set the SPI Clock Control register according to
+ * SPI slave device freq.
+ */
+static int davinci_spi_setup_transfer(struct spi_device *spi,
+		struct spi_transfer *t)
+{
+
+	struct davinci_spi *davinci_spi;
+	struct davinci_spi_platform_data *pdata;
+	u8 bits_per_word = 0;
+	u32 hz = 0, prescale;
+
+	davinci_spi = spi_master_get_devdata(spi->master);
+	pdata = davinci_spi->pdata;
+
+	if (t) {
+		bits_per_word = t->bits_per_word;
+		hz = t->speed_hz;
+	}
+
+	/* if bits_per_word is not set then set it default */
+	if (!bits_per_word)
+		bits_per_word = spi->bits_per_word;
+
+	/* Assign function pointer to appropriate transfer method */
+	/* 8bit/16bit or 32bit transfer */
+	if (bits_per_word <= 8 && bits_per_word >= 2) {
+		davinci_spi->get_rx = davinci_spi_rx_buf_u8;
+		davinci_spi->get_tx = davinci_spi_tx_buf_u8;
+		davinci_spi->slave[spi->chip_select].bytes_per_word = 1;
+	} else if (bits_per_word <= 16 && bits_per_word >= 2) {
+		davinci_spi->get_rx = davinci_spi_rx_buf_u16;
+		davinci_spi->get_tx = davinci_spi_tx_buf_u16;
+		davinci_spi->slave[spi->chip_select].bytes_per_word = 2;
+	} else
+		return -1;
+
+	if (!hz) {
+		hz = spi->max_speed_hz;
+		if (!hz) {
+			hz = 2000000;	/* defaulting to 2Mhz */
+			pr_info("[SPI] -> Slave device speed not set "
+				"correctly. Trying with %dHz\n", hz);
+		}
+	}
+
+	clear_fmt_bits(davinci_spi->base, SPI_SPIFMT_CHARLEN_MASK);
+	set_fmt_bits(davinci_spi->base, bits_per_word & 0x1f);
+
+	prescale = ((clk_get_rate(pdata->clk_info) / hz) - 1) & 0xff;
+
+	clear_fmt_bits(davinci_spi->base, 0x0000ff00);
+	set_fmt_bits(davinci_spi->base, prescale << 8);
+
+	return 0;
+}
+
+static void davinci_spi_dma_rx_callback(unsigned lch, u16 ch_status, void *data)
+{
+	struct spi_device *spi = (struct spi_device *)data;
+	struct davinci_spi *davinci_spi;
+	struct davinci_spi_dma *davinci_spi_dma;
+
+	davinci_spi = spi_master_get_devdata(spi->master);
+	davinci_spi_dma = &(davinci_spi->dma_channels[spi->chip_select]);
+
+	if (ch_status == DMA_COMPLETE)
+		edma_stop(davinci_spi_dma->dma_rx_channel);
+	else
+		edma_clean_channel(davinci_spi_dma->dma_rx_channel);
+
+	complete(&davinci_spi_dma->dma_rx_completion);
+	/* We must disable the DMA RX request */
+	davinci_spi_set_dma_req(spi, 0);
+
+}
+
+static void davinci_spi_dma_tx_callback(unsigned lch, u16 ch_status, void *data)
+{
+	struct spi_device *spi = (struct spi_device *)data;
+	struct davinci_spi *davinci_spi;
+	struct davinci_spi_dma *davinci_spi_dma;
+
+	davinci_spi = spi_master_get_devdata(spi->master);
+	davinci_spi_dma = &(davinci_spi->dma_channels[spi->chip_select]);
+
+	if (ch_status == DMA_COMPLETE)
+		edma_stop(davinci_spi_dma->dma_tx_channel);
+	else
+		edma_clean_channel(davinci_spi_dma->dma_tx_channel);
+
+	complete(&davinci_spi_dma->dma_tx_completion);
+	/* We must disable the DMA TX request */
+	davinci_spi_set_dma_req(spi, 0);
+
+}
+
+static int davinci_spi_request_dma(struct spi_device *spi)
+{
+	struct davinci_spi *davinci_spi;
+	struct davinci_spi_dma *davinci_spi_dma;
+	int r;
+
+	davinci_spi = spi_master_get_devdata(spi->master);
+	davinci_spi_dma = &davinci_spi->dma_channels[spi->chip_select];
+
+	r = edma_alloc_channel(davinci_spi_dma->dma_rx_sync_dev,
+				davinci_spi_dma_rx_callback, spi,
+				davinci_spi_dma->eventq);
+	if (r < 0) {
+		pr_err("Unable to request DMA channel for MibSPI RX\n");
+		return -EAGAIN;
+	}
+	davinci_spi_dma->dma_rx_channel = r;
+	r = edma_alloc_channel(davinci_spi_dma->dma_tx_sync_dev,
+				davinci_spi_dma_tx_callback, spi,
+				davinci_spi_dma->eventq);
+	if (r < 0) {
+		edma_free_channel(davinci_spi_dma->dma_rx_channel);
+		davinci_spi_dma->dma_rx_channel = -1;
+		pr_err("Unable to request DMA channel for MibSPI TX\n");
+		return -EAGAIN;
+	}
+	davinci_spi_dma->dma_tx_channel = r;
+
+	return 0;
+}
+
+/**
+ * davinci_spi_setup - This functions will set default transfer method
+ * @spi: spi device on which data transfer to be done
+ *
+ * This functions sets the default transfer method.
+ */
+
+static int davinci_spi_setup(struct spi_device *spi)
+{
+	int retval;
+	struct davinci_spi *davinci_spi;
+	struct davinci_spi_dma *davinci_spi_dma;
+
+	davinci_spi = spi_master_get_devdata(spi->master);
+
+	/* if bits per word length is zero then set it default 8 */
+	if (!spi->bits_per_word)
+		spi->bits_per_word = 8;
+
+	davinci_spi->slave[spi->chip_select].cmd_to_write = 0;
+
+	if (use_dma && davinci_spi->dma_channels) {
+		davinci_spi_dma = &davinci_spi->dma_channels[spi->chip_select];
+
+		if ((davinci_spi_dma->dma_rx_channel == -1)
+				|| (davinci_spi_dma->dma_tx_channel == -1)) {
+			retval = davinci_spi_request_dma(spi);
+			if (retval < 0)
+				return retval;
+		}
+	}
+
+	retval = davinci_spi_setup_transfer(spi, NULL);
+
+	return retval;
+}
+
+static void davinci_spi_cleanup(const struct spi_device *spi)
+{
+	struct davinci_spi *davinci_spi = spi_master_get_devdata(spi->master);
+	struct davinci_spi_dma *davinci_spi_dma;
+
+	davinci_spi_dma = &davinci_spi->dma_channels[spi->chip_select];
+
+	if (use_dma && davinci_spi->dma_channels) {
+		davinci_spi_dma = &davinci_spi->dma_channels[spi->chip_select];
+
+		if ((davinci_spi_dma->dma_rx_channel != -1)
+				&& (davinci_spi_dma->dma_tx_channel != -1)) {
+			edma_free_channel(davinci_spi_dma->dma_tx_channel);
+			edma_free_channel(davinci_spi_dma->dma_rx_channel);
+		}
+	}
+}
+
+static int davinci_spi_bufs_prep(struct spi_device *spi,
+				 struct davinci_spi *davinci_spi,
+				 struct davinci_spi_config_t *spi_cfg)
+{
+	u32 sPIPC0;
+
+	/* configuraton parameter for SPI */
+	if (spi_cfg->lsb_first)
+		set_fmt_bits(davinci_spi->base, SPI_SPIFMT_SHIFTDIR_MASK);
+	else
+		clear_fmt_bits(davinci_spi->base, SPI_SPIFMT_SHIFTDIR_MASK);
+
+	if (spi_cfg->clk_high)
+		set_fmt_bits(davinci_spi->base, SPI_SPIFMT_POLARITY_MASK);
+	else
+		clear_fmt_bits(davinci_spi->base, SPI_SPIFMT_POLARITY_MASK);
+
+	if (spi_cfg->phase_in)
+		set_fmt_bits(davinci_spi->base, SPI_SPIFMT_PHASE_MASK);
+	else
+		clear_fmt_bits(davinci_spi->base, SPI_SPIFMT_PHASE_MASK);
+
+	if (davinci_spi->version == DAVINCI_SPI_VERSION_2) {
+		clear_fmt_bits(davinci_spi->base, SPI_SPIFMT_WDELAY_MASK);
+		set_fmt_bits(davinci_spi->base,
+				((spi_cfg->wdelay << SPI_SPIFMT_WDELAY_SHIFT)
+					 & SPI_SPIFMT_WDELAY_MASK));
+
+		if (spi_cfg->odd_parity)
+			set_fmt_bits(davinci_spi->base,
+					SPI_SPIFMT_ODD_PARITY_MASK);
+		else
+			clear_fmt_bits(davinci_spi->base,
+					SPI_SPIFMT_ODD_PARITY_MASK);
+
+		if (spi_cfg->parity_enable)
+			set_fmt_bits(davinci_spi->base,
+					SPI_SPIFMT_PARITYENA_MASK);
+		else
+			clear_fmt_bits(davinci_spi->base,
+					SPI_SPIFMT_PARITYENA_MASK);
+
+		if (spi_cfg->wait_enable)
+			set_fmt_bits(davinci_spi->base,
+					SPI_SPIFMT_WAITENA_MASK);
+		else
+			clear_fmt_bits(davinci_spi->base,
+					SPI_SPIFMT_WAITENA_MASK);
+
+		if (spi_cfg->timer_disable)
+			set_fmt_bits(davinci_spi->base,
+					SPI_SPIFMT_DISTIMER_MASK);
+		else
+			clear_fmt_bits(davinci_spi->base,
+					SPI_SPIFMT_DISTIMER_MASK);
+	}
+
+	/* Clock internal */
+	if (spi_cfg->clk_internal)
+		set_bits(davinci_spi->base + SPIGCR1, SPI_SPIGCR1_CLKMOD_MASK);
+	else
+		clear_bits(davinci_spi->base + SPIGCR1,
+				SPI_SPIGCR1_CLKMOD_MASK);
+
+	/* master mode default */
+	set_bits(davinci_spi->base + SPIGCR1, SPI_SPIGCR1_MASTER_MASK);
+
+	if (spi_cfg->intr_level)
+		iowrite32(SPI_INTLVL_1, davinci_spi->base + SPILVL);
+	else
+		iowrite32(SPI_INTLVL_0, davinci_spi->base + SPILVL);
+
+	switch (spi_cfg->pin_op_modes) {
+	case SPI_OPMODE_3PIN:
+		sPIPC0 = (SPI_SPIPC0_DIFUN_DI << SPI_SPIPC0_DIFUN_SHIFT)
+			| (SPI_SPIPC0_DOFUN_DO << SPI_SPIPC0_DOFUN_SHIFT)
+			| (SPI_SPIPC0_CLKFUN_CLK << SPI_SPIPC0_CLKFUN_SHIFT);
+		break;
+
+	case SPI_OPMODE_SPISCS_4PIN:
+		sPIPC0 = (SPI_SPIPC0_DIFUN_DI << SPI_SPIPC0_DIFUN_SHIFT)
+			| (SPI_SPIPC0_DOFUN_DO << SPI_SPIPC0_DOFUN_SHIFT)
+			| (SPI_SPIPC0_CLKFUN_CLK << SPI_SPIPC0_CLKFUN_SHIFT)
+			| (1 << spi->chip_select);
+		break;
+
+	case SPI_OPMODE_SPIENA_4PIN:
+		sPIPC0 = (SPI_SPIPC0_DIFUN_DI << SPI_SPIPC0_DIFUN_SHIFT)
+			| (SPI_SPIPC0_DOFUN_DO << SPI_SPIPC0_DOFUN_SHIFT)
+			| (SPI_SPIPC0_CLKFUN_CLK << SPI_SPIPC0_CLKFUN_SHIFT)
+			| (SPI_SPIPC0_SPIENA << SPI_SPIPC0_SPIENA_SHIFT);
+		break;
+
+	case SPI_OPMODE_5PIN:
+		sPIPC0 = (SPI_SPIPC0_DIFUN_DI << SPI_SPIPC0_DIFUN_SHIFT)
+			| (SPI_SPIPC0_DOFUN_DO << SPI_SPIPC0_DOFUN_SHIFT)
+			| (SPI_SPIPC0_CLKFUN_CLK << SPI_SPIPC0_CLKFUN_SHIFT)
+			| (SPI_SPIPC0_SPIENA << SPI_SPIPC0_SPIENA_SHIFT)
+			| (1 << spi->chip_select);
+		break;
+
+	default:
+		return -1;
+	}
+
+	iowrite32(sPIPC0, davinci_spi->base + SPIPC0);
+
+	if (spi_cfg->loop_back)
+		set_bits(davinci_spi->base + SPIGCR1,
+				SPI_SPIGCR1_LOOPBACK_MASK);
+	else
+		clear_bits(davinci_spi->base + SPIGCR1,
+				SPI_SPIGCR1_LOOPBACK_MASK);
+
+	return 0;
+}
+
+static int davinci_spi_check_error(struct davinci_spi *davinci_spi,
+		int int_status)
+{
+	int ret = 0;
+
+	if (int_status & SPI_SPIFLG_TIMEOUT_MASK) {
+		pr_info("SPI Time-out Error\n");
+		ret = SPI_TIMEOUT_ERR;
+	}
+	if (int_status & SPI_SPIFLG_DESYNC_MASK) {
+		pr_info("SPI Desynchronization Error\n");
+		ret = SPI_DESYNC_ERR;
+	}
+	if (int_status & SPI_SPIFLG_BITERR_MASK) {
+		pr_info("SPI Bit error\n");
+		ret = SPI_BIT_ERR;
+	}
+
+	if (davinci_spi->version > DAVINCI_SPI_VERSION_2) {
+		if (int_status & SPI_SPIFLG_DLEN_ERR_MASK) {
+			pr_info("SPI Data Length Error\n");
+			ret = SPI_DLEN_ERR;
+		}
+		if (int_status & SPI_SPIFLG_PARERR_MASK) {
+			pr_info("SPI Parity Error\n");
+			ret = SPI_DLEN_ERR;
+		}
+		if (int_status & SPI_SPIFLG_OVRRUN_MASK) {
+			pr_info("SPI Data Overrun error\n");
+			ret = SPI_OVERRUN_ERR;
+		}
+		if (int_status & SPI_SPIFLG_TX_INTR_MASK) {
+			pr_info("SPI TX intr bit set\n");
+			ret = SPI_TX_INTR_ERR;
+		}
+		if (int_status & SPI_SPIFLG_BUF_INIT_ACTIVE_MASK) {
+			pr_info("SPI Buffer Init Active\n");
+			ret = SPI_BUF_INIT_ACTIVE_ERR;
+		}
+	}
+
+	return ret;
+}
+
+/**
+ * davinci_spi_bufs - functions which will handle transfer data
+ * @spi: spi device on which data transfer to be done
+ * @t: spi transfer in which transfer info is filled
+ *
+ * This function will put data to be transferred into data register
+ * of SPI controller and then wait untill the completion will be marked
+ * by the IRQ Handler.
+ */
+static int davinci_spi_bufs_pio(struct spi_device *spi, struct spi_transfer *t)
+{
+	struct davinci_spi *davinci_spi;
+	int int_status, count, ret;
+	u8 conv, tmp;
+	u32 tx_data, data1_reg_val;
+	struct davinci_spi_config_t *spi_cfg;
+	u32 buf_val, flg_val;
+	struct davinci_spi_platform_data *pdata;
+
+	davinci_spi = spi_master_get_devdata(spi->master);
+	pdata = davinci_spi->pdata;
+
+	davinci_spi->tx = t->tx_buf;
+	davinci_spi->rx = t->rx_buf;
+
+	/* convert len to words bbased on bits_per_word */
+	conv = davinci_spi->slave[spi->chip_select].bytes_per_word;
+	davinci_spi->count = t->len / conv;
+
+	INIT_COMPLETION(davinci_spi->done);
+
+	spi_cfg = (struct davinci_spi_config_t *)spi->controller_data;
+
+	ret = davinci_spi_bufs_prep(spi, davinci_spi, spi_cfg);
+	if (ret)
+		return ret;
+
+	/* Enable SPI */
+	set_bits(davinci_spi->base + SPIGCR1, SPI_SPIGCR1_SPIENA_MASK);
+
+	/* Put delay val if required */
+	iowrite32(0 | (8 << 24) | (8 << 16), davinci_spi->base + SPIDELAY);
+
+	count = davinci_spi->count;
+	data1_reg_val = spi_cfg->cs_hold << SPI_SPIDAT1_CSHOLD_SHIFT;
+
+	tmp = ~(0x1 << spi->chip_select);
+	/* CD default = 0xFF */
+	/* check for GPIO */
+	if ((pdata->chip_sel != NULL) &&
+	    (pdata->chip_sel[spi->chip_select] != DAVINCI_SPI_INTERN_CS))
+		gpio_set_value(pdata->chip_sel[spi->chip_select], 0);
+	 else
+		clear_bits(davinci_spi->base + SPIDEF, ~tmp);
+
+	data1_reg_val |= tmp << SPI_SPIDAT1_CSNR_SHIFT;
+
+	while (1)
+		if (ioread32(davinci_spi->base + SPIBUF)
+				& SPI_SPIBUF_RXEMPTY_MASK)
+			break;
+
+	/* Determine the command to execute READ or WRITE */
+	if (t->tx_buf) {
+		clear_bits(davinci_spi->base + SPIINT, SPI_SPIINT_MASKALL);
+
+		while (1) {
+			tx_data = davinci_spi->get_tx(davinci_spi);
+
+			data1_reg_val &= ~(0xFFFF);
+			data1_reg_val |= (0xFFFF & tx_data);
+
+
+			buf_val = ioread32(davinci_spi->base + SPIBUF);
+			if ((buf_val & SPI_SPIBUF_TXFULL_MASK) == 0) {
+				iowrite32(data1_reg_val,
+						davinci_spi->base + SPIDAT1);
+
+				count--;
+			}
+			while (ioread32(davinci_spi->base + SPIBUF)
+					& SPI_SPIBUF_RXEMPTY_MASK)
+				udelay(1);
+			/* getting the returned byte */
+			if (t->rx_buf) {
+				buf_val = ioread32(davinci_spi->base + SPIBUF);
+				davinci_spi->get_rx(buf_val, davinci_spi);
+			}
+			if (count <= 0)
+				break;
+		}
+	} else {
+		if (spi_cfg->poll_mode) {	/* In Polling mode receive */
+			while (1) {
+				/* keeps the serial clock going */
+				if ((ioread32(davinci_spi->base + SPIBUF)
+						& SPI_SPIBUF_TXFULL_MASK) == 0)
+					iowrite32(data1_reg_val,
+						davinci_spi->base + SPIDAT1);
+
+				while (ioread32(davinci_spi->base + SPIBUF)
+						& SPI_SPIBUF_RXEMPTY_MASK) {
+				}
+
+				flg_val = ioread32(davinci_spi->base + SPIFLG);
+				buf_val = ioread32(davinci_spi->base + SPIBUF);
+
+				davinci_spi->get_rx(buf_val, davinci_spi);
+
+				count--;
+				if (count <= 0)
+					break;
+			}
+		} else {	/* Receive in Interrupt mode */
+			int i;
+
+			for (i = 0; i < davinci_spi->count; i++) {
+				set_bits(davinci_spi->base + SPIINT,
+						SPI_SPIINT_BITERR_INTR
+						| SPI_SPIINT_OVRRUN_INTR
+						| SPI_SPIINT_RX_INTR);
+
+				iowrite32(data1_reg_val,
+						davinci_spi->base + SPIDAT1);
+
+				while (ioread32(davinci_spi->base + SPIINT)
+						& SPI_SPIINT_RX_INTR) {
+				}
+			}
+			iowrite32((data1_reg_val & 0x0ffcffff),
+					davinci_spi->base + SPIDAT1);
+		}
+	}
+
+	/*
+	 * Check for bit error, desync error,parity error,timeout error and
+	 * receive overflow errors
+	 */
+	int_status = ioread32(davinci_spi->base + SPIFLG);
+
+	ret = davinci_spi_check_error(davinci_spi, int_status);
+	if (ret != 0)
+		return ret;
+
+	/* SPI Framework maintains the count only in bytes so convert back */
+	davinci_spi->count *= conv;
+
+	return t->len;
+}
+
+#define DAVINCI_DMA_DATA_TYPE_S8	0x01
+#define DAVINCI_DMA_DATA_TYPE_S16	0x02
+#define DAVINCI_DMA_DATA_TYPE_S32	0x04
+
+static int davinci_spi_bufs_dma(struct spi_device *spi, struct spi_transfer *t)
+{
+	struct davinci_spi *davinci_spi;
+	int int_status = 0;
+	int count;
+	u8 conv = 1;
+	u8 tmp;
+	u32 data1_reg_val;
+	struct davinci_spi_dma *davinci_spi_dma;
+	int word_len, data_type, ret;
+	unsigned long tx_reg, rx_reg;
+	struct davinci_spi_config_t *spi_cfg;
+	struct davinci_spi_platform_data *pdata;
+
+	davinci_spi = spi_master_get_devdata(spi->master);
+	pdata = davinci_spi->pdata;
+
+	BUG_ON(davinci_spi->dma_channels == NULL);
+
+	davinci_spi_dma = &davinci_spi->dma_channels[spi->chip_select];
+
+	tx_reg = (unsigned long)davinci_spi->pbase + SPIDAT1;
+	rx_reg = (unsigned long)davinci_spi->pbase + SPIBUF;
+
+	/* used for macro defs */
+	davinci_spi->tx = t->tx_buf;
+	davinci_spi->rx = t->rx_buf;
+
+	/* convert len to words bbased on bits_per_word */
+	conv = davinci_spi->slave[spi->chip_select].bytes_per_word;
+	davinci_spi->count = t->len / conv;
+
+	INIT_COMPLETION(davinci_spi->done);
+
+	init_completion(&davinci_spi_dma->dma_rx_completion);
+	init_completion(&davinci_spi_dma->dma_tx_completion);
+
+	word_len = conv * 8;
+	if (word_len <= 8)
+		data_type = DAVINCI_DMA_DATA_TYPE_S8;
+	else if (word_len <= 16)
+		data_type = DAVINCI_DMA_DATA_TYPE_S16;
+	else if (word_len <= 32)
+		data_type = DAVINCI_DMA_DATA_TYPE_S32;
+	else
+		return -1;
+
+	spi_cfg = (struct davinci_spi_config_t *)spi->controller_data;
+
+	ret = davinci_spi_bufs_prep(spi, davinci_spi, spi_cfg);
+	if (ret)
+		return ret;
+
+	/* Put delay val if required */
+	iowrite32(0, davinci_spi->base + SPIDELAY);
+
+	count = davinci_spi->count;	/* the number of elements */
+	data1_reg_val = spi_cfg->cs_hold << SPI_SPIDAT1_CSHOLD_SHIFT;
+
+	/* CD default = 0xFF */
+	tmp = ~(0x1 << spi->chip_select);
+	if ((pdata->chip_sel != NULL) &&
+	    (pdata->chip_sel[spi->chip_select] != DAVINCI_SPI_INTERN_CS))
+		gpio_set_value(pdata->chip_sel[spi->chip_select], 0);
+	 else
+		clear_bits(davinci_spi->base + SPIDEF, ~tmp);
+
+	data1_reg_val |= tmp << SPI_SPIDAT1_CSNR_SHIFT;
+
+	/* disable all interrupts for dma transfers */
+	clear_bits(davinci_spi->base + SPIINT, SPI_SPIINT_MASKALL);
+	/* Disable SPI to write configuration bits in SPIDAT */
+	clear_bits(davinci_spi->base + SPIGCR1, SPI_SPIGCR1_SPIENA_MASK);
+	iowrite32(data1_reg_val, davinci_spi->base + SPIDAT1);
+	/* Enable SPI */
+	set_bits(davinci_spi->base + SPIGCR1, SPI_SPIGCR1_SPIENA_MASK);
+
+	while (1)
+		if (ioread32(davinci_spi->base + SPIBUF)
+				& SPI_SPIBUF_RXEMPTY_MASK)
+			break;
+
+	if (t->tx_buf != NULL) {
+		t->tx_dma = dma_map_single(&spi->dev, (void *)t->tx_buf, count,
+				DMA_TO_DEVICE);
+		/*if (dma_mapping_error(t->tx_dma)) {
+			pr_err("%s(): Couldn't DMA map a %d bytes TX buffer\n",
+					__func__, count);
+			return -1;
+		}*/
+		edma_set_transfer_params(davinci_spi_dma->dma_tx_channel,
+				data_type, count, 1, 0, ASYNC);
+		edma_set_dest(davinci_spi_dma->dma_tx_channel,
+				tx_reg, INCR, W8BIT);
+		edma_set_src(davinci_spi_dma->dma_tx_channel,
+				t->tx_dma, INCR, W8BIT);
+		edma_set_src_index(davinci_spi_dma->dma_tx_channel,
+				data_type, 0);
+		edma_set_dest_index(davinci_spi_dma->dma_tx_channel, 0,
+				0);
+	} else {
+		/* We need TX clocking for RX transaction */
+		t->tx_dma = dma_map_single(&spi->dev,
+				(void *)davinci_spi->tmp_buf, count + 1,
+				DMA_TO_DEVICE);
+		/*if (dma_mapping_error(t->tx_dma)) {
+			pr_err("%s(): Couldn't DMA map a %d bytes TX "
+				"tmp buffer\n", __func__, count);
+			return -1;
+		}*/
+		edma_set_transfer_params(davinci_spi_dma->dma_tx_channel,
+				data_type, count + 1, 1, 0, ASYNC);
+		edma_set_dest(davinci_spi_dma->dma_tx_channel,
+				tx_reg, INCR, W8BIT);
+		edma_set_src(davinci_spi_dma->dma_tx_channel,
+				t->tx_dma, INCR, W8BIT);
+		edma_set_src_index(davinci_spi_dma->dma_tx_channel,
+				data_type, 0);
+		edma_set_dest_index(davinci_spi_dma->dma_tx_channel, 0,
+				0);
+	}
+
+	if (t->rx_buf != NULL) {
+		/* initiate transaction */
+		iowrite32(data1_reg_val, davinci_spi->base + SPIDAT1);
+
+		t->rx_dma = dma_map_single(&spi->dev, (void *)t->rx_buf, count,
+				DMA_FROM_DEVICE);
+		/*if (dma_mapping_error(t->rx_dma)) {
+			pr_err("%s(): Couldn't DMA map a %d bytes RX buffer\n",
+				__func__, count);
+			if (t->tx_buf != NULL)
+				dma_unmap_single(NULL, t->tx_dma,
+						 count, DMA_TO_DEVICE);
+			return -1;
+		}*/
+		edma_set_transfer_params(davinci_spi_dma->dma_rx_channel,
+				data_type, count, 1, 0, ASYNC);
+		edma_set_src(davinci_spi_dma->dma_rx_channel,
+				rx_reg, INCR, W8BIT);
+		edma_set_dest(davinci_spi_dma->dma_rx_channel,
+				t->rx_dma, INCR, W8BIT);
+		edma_set_src_index(davinci_spi_dma->dma_rx_channel, 0,
+				0);
+		edma_set_dest_index(davinci_spi_dma->dma_rx_channel,
+				data_type, 0);
+	}
+
+	if ((t->tx_buf != NULL) || (t->rx_buf != NULL))
+		edma_start(davinci_spi_dma->dma_tx_channel);
+
+	if (t->rx_buf != NULL)
+		edma_start(davinci_spi_dma->dma_rx_channel);
+
+	if ((t->rx_buf != NULL) || (t->tx_buf != NULL))
+		davinci_spi_set_dma_req(spi, 1);
+
+	if (t->tx_buf != NULL)
+		wait_for_completion_interruptible(
+				&davinci_spi_dma->dma_tx_completion);
+
+	if (t->rx_buf != NULL)
+		wait_for_completion_interruptible(
+				&davinci_spi_dma->dma_rx_completion);
+
+	if (t->tx_buf != NULL)
+		dma_unmap_single(NULL, t->tx_dma, count, DMA_TO_DEVICE);
+	else
+		dma_unmap_single(NULL, t->tx_dma, count + 1, DMA_TO_DEVICE);
+
+	if (t->rx_buf != NULL)
+		dma_unmap_single(NULL, t->rx_dma, count, DMA_FROM_DEVICE);
+
+	/*
+	 * Check for bit error, desync error,parity error,timeout error and
+	 * receive overflow errors
+	 */
+	int_status = ioread32(davinci_spi->base + SPIFLG);
+
+	ret = davinci_spi_check_error(davinci_spi, int_status);
+	if (ret != 0)
+		return ret;
+
+	/* SPI Framework maintains the count only in bytes so convert back */
+	davinci_spi->count *= conv;
+
+	return t->len;
+}
+
+/**
+ * davinci_spi_irq - probe function for SPI Master Controller
+ * @irq: IRQ number for this SPI Master
+ * @context_data: structure for SPI Master controller davinci_spi
+ * @ptregs:
+ *
+ * ISR will determine that interrupt arrives either for READ or WRITE command.
+ * According to command it will do the appropriate action. It will check
+ * transfer length and if it is not zero then dispatch transfer command again.
+ * If transfer length is zero then it will indicate the COMPLETION so that
+ * davinci_spi_bufs function can go ahead.
+ */
+static irqreturn_t davinci_spi_irq(s32 irq, void *context_data)
+{
+	struct davinci_spi *davinci_spi = context_data;
+	u32 int_status, rx_data = 0;
+	irqreturn_t ret = IRQ_NONE;
+
+	int_status = ioread32(davinci_spi->base + SPIFLG);
+	while ((int_status & SPI_SPIFLG_MASK) != 0) {
+		ret = IRQ_HANDLED;
+
+		if (likely(int_status & SPI_SPIFLG_RX_INTR_MASK)) {
+			rx_data = ioread32(davinci_spi->base + SPIBUF);
+			davinci_spi->get_rx(rx_data, davinci_spi);
+
+			/* Disable Receive Interrupt */
+			iowrite32(~SPI_SPIINT_RX_INTR,
+					davinci_spi->base + SPIINT);
+		} else /* Ignore errors if have good intr */
+			(void)davinci_spi_check_error(davinci_spi, int_status);
+
+		int_status = ioread32(davinci_spi->base + SPIFLG);
+	}
+
+	return ret;
+}
+
+#define	DAVINCI_SPI_NO_RESOURCE		((resource_size_t)-1)
+
+resource_size_t davinci_spi_get_dma_by_flag(struct platform_device *dev,
+		unsigned long flag)
+{
+	struct resource *r;
+	int i;
+
+	for (i = 0; i < 10; i++) {
+		/* Non-resource type flags will be AND'd off */
+		r = platform_get_resource(dev, IORESOURCE_DMA, i);
+		if (r == NULL)
+			break;
+		if ((r->flags & flag) == flag)
+			return r->start;
+	}
+
+	return DAVINCI_SPI_NO_RESOURCE;
+}
+
+/**
+ * davinci_spi_probe - probe function for SPI Master Controller
+ * @dev: platform_device structure which contains plateform specific data
+ *
+ * According to Linux Deviced Model this function will be invoked by Linux
+ * with plateform_device struct which contains the device specific info
+ * like bus_num, num_chipselect (how many slave devices can be connected),
+ * clock freq. of SPI controller, SPI controller's memory range, IRQ number etc.
+ * This info will be provided by board specific code which will reside in
+ * linux-2.6.10/arch/mips/mips-boards/davinci_davinci/davinci_yamuna code.
+ * This function will map the SPI controller's memory, register IRQ,
+ * Reset SPI controller and setting its registers to default value.
+ * It will invoke spi_bitbang_start to create work queue so that client driver
+ * can register transfer method to work queue.
+ */
+static int davinci_spi_probe(struct device *d)
+{
+	struct platform_device *dev =
+		container_of(d, struct platform_device, dev);
+	struct spi_master *master;
+	struct davinci_spi *davinci_spi;
+	struct davinci_spi_platform_data *pdata;
+	struct resource *r, *mem;
+	resource_size_t dma_rx_chan, dma_tx_chan, dma_eventq;
+	int i = 0, ret = 0;
+
+	pdata = dev->dev.platform_data;
+	if (pdata == NULL) {
+		ret = -ENODEV;
+		goto err;
+	}
+
+	master = spi_alloc_master(&dev->dev, sizeof(struct davinci_spi));
+	if (master == NULL) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	dev_set_drvdata(&dev->dev, master);
+
+	davinci_spi = spi_master_get_devdata(master);
+	if (davinci_spi == NULL) {
+		ret = -ENOENT;
+		goto free_master;
+	}
+
+	r = platform_get_resource(dev, IORESOURCE_MEM, 0);
+	if (r == NULL) {
+		ret = -ENOENT;
+		goto free_master;
+	}
+
+	davinci_spi->pbase = r->start;
+	davinci_spi->region_size = r->end - r->start + 1;
+	davinci_spi->pdata = pdata;
+
+	/* initialize gpio used as chip select */
+	if (pdata->chip_sel != NULL) {
+		for (i = 0; i < pdata->num_chipselect; i++) {
+			if (pdata->chip_sel[i] != DAVINCI_SPI_INTERN_CS)
+				gpio_direction_output(pdata->chip_sel[i], 1);
+		}
+	}
+
+	mem = request_mem_region(r->start, davinci_spi->region_size, dev->name);
+	if (mem == NULL) {
+		ret = -EBUSY;
+		goto free_master;
+	}
+
+	davinci_spi->base = (struct davinci_spi_reg __iomem *)
+			ioremap(r->start, davinci_spi->region_size);
+	if (davinci_spi->base == NULL) {
+		ret = -ENOMEM;
+		goto release_region;
+	}
+
+	davinci_spi->irq = platform_get_irq(dev, 0);
+	if (davinci_spi->irq <= 0) {
+		ret = -EINVAL;
+		goto unmap_io;
+	}
+
+	ret = request_irq(davinci_spi->irq, davinci_spi_irq, IRQF_DISABLED,
+			  dev->name, davinci_spi);
+	if (ret != 0) {
+		ret = -EAGAIN;
+		goto unmap_io;
+	}
+
+	/* Allocate tmp_buf for tx_buf */
+	davinci_spi->tmp_buf = kzalloc(SPI_BUFSIZ, GFP_KERNEL);
+	if (davinci_spi->tmp_buf == NULL) {
+		ret = -ENOMEM;
+		goto release_irq;
+	}
+
+	davinci_spi->bitbang.master = spi_master_get(master);
+	if (davinci_spi->bitbang.master == NULL) {
+		ret = -ENODEV;
+		goto free_tmp_buf;
+	}
+
+	if (pdata->clk_name) {
+		pdata->clk_info = clk_get(d, pdata->clk_name);
+		if (IS_ERR(pdata->clk_info)) {
+			ret = -ENODEV;
+			goto put_master;
+		}
+		clk_enable(pdata->clk_info);
+	} else {
+		ret = -ENODEV;
+		goto put_master;
+	}
+
+	master->bus_num = dev->id;
+	master->num_chipselect = pdata->num_chipselect;
+	master->setup = davinci_spi_setup;
+	master->cleanup = davinci_spi_cleanup;
+
+	davinci_spi->bitbang.chipselect = davinci_spi_chipselect;
+	davinci_spi->bitbang.setup_transfer = davinci_spi_setup_transfer;
+
+	dma_rx_chan = davinci_spi_get_dma_by_flag(dev, IORESOURCE_DMA_RX_CHAN);
+	dma_tx_chan = davinci_spi_get_dma_by_flag(dev, IORESOURCE_DMA_TX_CHAN);
+	dma_eventq  = davinci_spi_get_dma_by_flag(dev, IORESOURCE_DMA_EVENT_Q);
+
+	if (!use_dma ||
+	    dma_rx_chan == DAVINCI_SPI_NO_RESOURCE ||
+	    dma_tx_chan == DAVINCI_SPI_NO_RESOURCE ||
+	    dma_eventq	== DAVINCI_SPI_NO_RESOURCE) {
+		davinci_spi->bitbang.txrx_bufs = davinci_spi_bufs_pio;
+		use_dma = 0;
+	} else {
+		davinci_spi->bitbang.txrx_bufs = davinci_spi_bufs_dma;
+
+		davinci_spi->dma_channels = kzalloc(master->num_chipselect
+				* sizeof(struct davinci_spi_dma), GFP_KERNEL);
+		if (davinci_spi->dma_channels == NULL) {
+			ret = -ENOMEM;
+			goto free_clk;
+		}
+
+		for (i = 0; i < master->num_chipselect; i++) {
+			davinci_spi->dma_channels[i].dma_rx_channel = -1;
+			davinci_spi->dma_channels[i].dma_rx_sync_dev =
+				dma_rx_chan;
+			davinci_spi->dma_channels[i].dma_tx_channel = -1;
+			davinci_spi->dma_channels[i].dma_tx_sync_dev =
+				dma_tx_chan;
+			davinci_spi->dma_channels[i].eventq = dma_eventq;
+		}
+	}
+
+	davinci_spi->version = pdata->version;
+	davinci_spi->get_rx = davinci_spi_rx_buf_u8;
+	davinci_spi->get_tx = davinci_spi_tx_buf_u8;
+
+	init_completion(&davinci_spi->done);
+
+	/* Reset In/OUT SPI modle */
+	iowrite32(0, davinci_spi->base + SPIGCR0);
+	udelay(100);
+	iowrite32(1, davinci_spi->base + SPIGCR0);
+
+	ret = spi_bitbang_start(&davinci_spi->bitbang);
+	if (ret != 0)
+		goto free_dma;
+
+	pr_info("%s: davinci SPI Controller driver at "
+		"0x%p (irq = %d) use_dma=%d\n",
+		dev->dev.bus_id, davinci_spi->base, davinci_spi->irq, use_dma);
+
+	return ret;
+
+free_dma:
+	kfree(davinci_spi->dma_channels);
+free_clk:
+	clk_disable(pdata->clk_info);
+	clk_put(pdata->clk_info);
+	pdata->clk_info = NULL;
+put_master:
+	spi_master_put(master);
+free_tmp_buf:
+	kfree(davinci_spi->tmp_buf);
+release_irq:
+	free_irq(davinci_spi->irq, davinci_spi);
+unmap_io:
+	iounmap(davinci_spi->base);
+release_region:
+	release_mem_region(davinci_spi->pbase, davinci_spi->region_size);
+free_master:
+	kfree(master);
+err:
+	return ret;
+}
+
+/**
+ * davinci_spi_remove - remove function for SPI Master Controller
+ * @dev: platform_device structure which contains plateform specific data
+ *
+ * This function will do the reverse action of davinci_spi_probe function
+ * It will free the IRQ and SPI controller's memory region.
+ * It will also call spi_bitbang_stop to destroy the work queue which was
+ * created by spi_bitbang_start.
+ */
+static int __devexit davinci_spi_remove(struct device *d)
+{
+	struct platform_device *dev =
+		container_of(d, struct platform_device, dev);
+	struct davinci_spi *davinci_spi;
+	struct spi_master *master;
+	struct davinci_spi_platform_data *pdata = platform_get_drvdata(dev);
+
+	clk_disable(pdata->clk_info);
+	clk_put(pdata->clk_info);
+
+	master = dev_get_drvdata(&(dev)->dev);
+	davinci_spi = spi_master_get_devdata(master);
+
+	spi_bitbang_stop(&davinci_spi->bitbang);
+
+	kfree(davinci_spi->dma_channels);
+	clk_disable(pdata->clk_info);
+	clk_put(pdata->clk_info);
+	pdata->clk_info = NULL;
+	spi_master_put(master);
+	kfree(davinci_spi->tmp_buf);
+	free_irq(davinci_spi->irq, davinci_spi);
+	iounmap(davinci_spi->base);
+	release_mem_region(davinci_spi->pbase, davinci_spi->region_size);
+	kfree(master);
+
+	return 0;
+}
+
+static struct device_driver davinci_spi_driver = {
+	.name = "dm_spi",
+	.bus = &platform_bus_type,
+	.probe = davinci_spi_probe,
+	.remove = __devexit_p(davinci_spi_remove),
+};
+
+static int __init davinci_spi_init(void)
+{
+	return driver_register(&davinci_spi_driver);
+}
+
+static void __exit davinci_spi_exit(void)
+{
+	driver_unregister(&davinci_spi_driver);
+}
+
+module_init(davinci_spi_init);
+module_exit(davinci_spi_exit);
+
+MODULE_AUTHOR("Dhruval Shah & Varun Shah");
+MODULE_DESCRIPTION("DM355 SPI Master Controller Driver");
+MODULE_LICENSE("GPL");
Index: primus-kernel/include/linux/spi/at25xxA_eeprom.h
===================================================================
--- /dev/null
+++ primus-kernel/include/linux/spi/at25xxA_eeprom.h
@@ -0,0 +1,50 @@
+/*
+ * DaVinci SPI-EEPROM client driver header file
+ *
+ * Author: Steve Chen <schen@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#ifndef DAVINCI_SPI_EEPROM_H
+#define DAVINCI_SPI_EEPROM_H
+
+#include <linux/cache.h>
+/*
+ *  EEPROM op-codes
+ */
+#define DAVINCI_EEPROM_READ	0x03	/* read */
+#define DAVINCI_EEPROM_WRITE	0x02	/* write */
+#define DAVINCI_EEPROM_WREN	0x06	/* write enable */
+#define DAVINCI_EEPROM_WRDIS	0x04	/* write disable */
+#define DAVINCI_EEPROM_RDSTAT	0x05	/* read status register */
+#define DAVINCI_EEPROM_WRSTAT	0x01	/* write status register */
+
+#define SPI_BUFFER_SIZE SMP_CACHE_BYTES
+#define DAVINCI_SPI_TX_CMD_SIZE 3
+
+#define DAVINCI_SPI_EEPROM_NAME "davinci_spi_eeprom"
+
+struct mtd_partition;
+
+struct davinci_eeprom_info {
+	unsigned int eeprom_size;
+	unsigned int page_size;
+	unsigned int page_mask;
+	unsigned long chip_sel;
+	unsigned int commit_delay;
+	struct spi_device *spi;
+	struct davinci_spi *spi_data;
+
+	struct mtd_partition *parts;
+	unsigned int nr_parts;
+
+	struct semaphore lock;
+	char tx_buffer[SPI_BUFFER_SIZE + DAVINCI_SPI_TX_CMD_SIZE];
+	char rx_buffer[SPI_BUFFER_SIZE];
+};
+
+#endif				/*DAVINCI_SPI_EEPROM_H */
Index: primus-kernel/include/linux/spi/davinci_spi.h
===================================================================
--- /dev/null
+++ primus-kernel/include/linux/spi/davinci_spi.h
@@ -0,0 +1,43 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __DAVINCI_SPI_H_
+#define __DAVINCI_SPI_H_
+
+#include <linux/clk.h>
+#include <mach/edma.h>
+
+/* resource flags for IORESOURCE_DMA resources */
+#define IORESOURCE_DMA_RX_CHAN		0x01
+#define IORESOURCE_DMA_TX_CHAN		0x02
+#define IORESOURCE_DMA_EVENT_Q		0x04
+
+#define DAVINCI_SPI_INTERN_CS		0xFF
+
+enum {
+	DAVINCI_SPI_VERSION_1, /* Original on most Davinci's */
+	DAVINCI_SPI_VERSION_2, /* New one on DA8xx */
+};
+
+struct davinci_spi_platform_data {
+	u8	version;
+	u16	num_chipselect;
+	u8	*chip_sel;
+	char	*clk_name;
+	struct clk *clk_info;
+};
+
+#endif				/* __DAVINCI_SPI_H_ */
Index: primus-kernel/include/linux/spi/davinci_spi_master.h
===================================================================
--- /dev/null
+++ primus-kernel/include/linux/spi/davinci_spi_master.h
@@ -0,0 +1,316 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/completion.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/device.h>
+#include <linux/spinlock.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/device.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/davinci_spi.h>
+#include <linux/spi/spi_bitbang.h>
+
+#include <mach/edma.h>
+
+/*Board specific declarations*/
+#define SPI_BUS_FREQ	(4000000)
+#define CS_DEFAULT	0xFF
+#define SCS0_SELECT	0x01
+#define SCS1_SELECT	0x02
+#define SCS2_SELECT	0x04
+#define SCS3_SELECT	0x08
+#define SCS4_SELECT	0x10
+#define SCS5_SELECT	0x20
+#define SCS6_SELECT	0x40
+#define SCS7_SELECT	0x80
+
+/* Standard values for DAVINCI */
+#define DAVINCI_SPI_MAX_CHIPSELECT 7
+
+/* #define SPI_INTERRUPT_MODE 1 */
+#define SPI_SPIFMT_PHASE_MASK		(0x00010000u)
+#define SPI_SPIFMT_PHASE_SHIFT		(0x00000010u)
+#define SPI_SPIFMT_PHASE_RESETVAL	(0x00000000u)
+
+#define SPI_SPIFMT_POLARITY_MASK	(0x00020000u)
+#define SPI_SPIFMT_POLARITY_SHIFT	(0x00000011u)
+#define SPI_SPIFMT_POLARITY_RESETVAL	(0x00000000u)
+
+#define SPI_SPIFMT_DISTIMER_MASK	(0x00040000u)
+#define SPI_SPIFMT_DISTIMER_SHIFT	(0x00000012u)
+#define SPI_SPIFMT_DISTIMER_RESETVAL	(0x00000000u)
+
+#define SPI_SPIFMT_SHIFTDIR_MASK	(0x00100000u)
+#define SPI_SPIFMT_SHIFTDIR_SHIFT	(0x00000014u)
+#define SPI_SPIFMT_SHIFTDIR_RESETVAL	(0x00000000u)
+
+#define SPI_SPIFMT_WAITENA_MASK		(0x00200000u)
+#define SPI_SPIFMT_WAITENA_SHIFT	(0x00000015u)
+#define SPI_SPIFMT_WAITENA_RESETVAL	(0x00000000u)
+
+#define SPI_SPIFMT_PARITYENA_MASK	(0x00400000u)
+#define SPI_SPIFMT_PARITYENA_SHIFT	(0x00000016u)
+#define SPI_SPIFMT_PARITYENA_RESETVAL	(0x00000000u)
+
+#define SPI_SPIFMT_ODD_PARITY_MASK	(0x00800000u)
+#define SPI_SPIFMT_ODD_PARITY_SHIFT	(0x00000017u)
+#define SPI_SPIFMT_ODD_PARITY_RESETVAL	(0x00000000u)
+
+#define SPI_SPIFMT_WDELAY_MASK		(0x3f000000u)
+#define SPI_SPIFMT_WDELAY_SHIFT		(0x00000018u)
+#define SPI_SPIFMT_WDELAY_RESETVAL	(0x00000000u)
+
+#define SPI_SPIFMT_CHARLEN_MASK		(0x0000001Fu)
+#define SPI_SPIFMT_CHARLEN_SHIFT	(0x00000000u)
+#define SPI_SPIFMT_CHARLEN_RESETVAL	(0x00000000u)
+
+/* SPIGCR1 */
+
+#define SPI_SPIGCR1_SPIENA_MASK      (0x01000000u)
+#define SPI_SPIGCR1_SPIENA_SHIFT     (0x00000018u)
+#define SPI_SPIGCR1_SPIENA_RESETVAL  (0x00000000u)
+
+#define SPI_INTLVL_1				 (0x000001FFu)
+#define SPI_INTLVL_0				 (0x00000000u)
+
+/* SPIPC0 */
+
+#define SPI_SPIPC0_DIFUN_MASK        (0x00000800u)
+#define SPI_SPIPC0_DIFUN_SHIFT       (0x0000000Bu)
+#define SPI_SPIPC0_DIFUN_RESETVAL    (0x00000000u)
+
+/*----DIFUN Tokens----*/
+#define SPI_SPIPC0_DIFUN_DI          (0x00000001u)
+
+#define SPI_SPIPC0_DOFUN_MASK        (0x00000400u)
+#define SPI_SPIPC0_DOFUN_SHIFT       (0x0000000Au)
+#define SPI_SPIPC0_DOFUN_RESETVAL    (0x00000000u)
+
+/*----DOFUN Tokens----*/
+#define SPI_SPIPC0_DOFUN_DO          (0x00000001u)
+
+#define SPI_SPIPC0_CLKFUN_MASK       (0x00000200u)
+#define SPI_SPIPC0_CLKFUN_SHIFT      (0x00000009u)
+#define SPI_SPIPC0_CLKFUN_RESETVAL   (0x00000000u)
+
+/*----CLKFUN Tokens----*/
+#define SPI_SPIPC0_CLKFUN_CLK        (0x00000001u)
+
+#define SPI_SPIPC0_EN1FUN_MASK       (0x00000002u)
+#define SPI_SPIPC0_EN1FUN_SHIFT      (0x00000001u)
+#define SPI_SPIPC0_EN1FUN_RESETVAL   (0x00000000u)
+
+/*----EN1FUN Tokens----*/
+#define SPI_SPIPC0_EN1FUN_EN1        (0x00000001u)
+
+#define SPI_SPIPC0_EN0FUN_MASK       (0x00000001u)
+#define SPI_SPIPC0_EN0FUN_SHIFT      (0x00000000u)
+#define SPI_SPIPC0_EN0FUN_RESETVAL   (0x00000000u)
+
+/*----EN0FUN Tokens----*/
+#define SPI_SPIPC0_EN0FUN_EN0        (0x00000001u)
+
+#define SPI_SPIPC0_RESETVAL          (0x00000000u)
+#define SPI_SPIPC0_SPIENA		 (0x00000001u)
+#define SPI_SPIPC0_SPIENA_SHIFT	 (0x00000008u)
+
+#define SPI_SPIINT_MASKALL		(0x0101035F)
+
+/* SPIDAT1 */
+
+#define SPI_SPIDAT1_CSHOLD_MASK      (0x10000000u)
+#define SPI_SPIDAT1_CSHOLD_SHIFT     (0x0000001Cu)
+#define SPI_SPIDAT1_CSHOLD_RESETVAL  (0x00000000u)
+
+#define SPI_SPIDAT1_CSNR_MASK        (0x00030000u)
+#define SPI_SPIDAT1_CSNR_SHIFT       (0x00000010u)
+#define SPI_SPIDAT1_CSNR_RESETVAL    (0x00000000u)
+
+#define SPI_SPIDAT1_DFSEL_MASK       (0x03000000u)
+#define SPI_SPIDAT1_DFSEL_SHIFT      (0x00000018u)
+#define SPI_SPIDAT1_DFSEL_RESETVAL   (0x00000000u)
+
+#define SPI_SPIGCR1_CLKMOD_MASK      (0x00000002u)
+#define SPI_SPIGCR1_CLKMOD_SHIFT     (0x00000001u)
+#define SPI_SPIGCR1_CLKMOD_RESETVAL  (0x00000000u)
+
+#define SPI_SPIGCR1_MASTER_MASK      (0x00000001u)
+#define SPI_SPIGCR1_MASTER_SHIFT     (0x00000000u)
+#define SPI_SPIGCR1_MASTER_RESETVAL  (0x00000000u)
+
+#define SPI_SPIGCR1_LOOPBACK_MASK    (0x00010000u)
+#define SPI_SPIGCR1_LOOPBACK_SHIFT   (0x00000010u)
+#define SPI_SPIGCR1_LOOPBACK_RESETVAL (0x00000000u)
+
+/* SPIBUF */
+#define SPI_SPIBUF_TXFULL_MASK		(0x20000000u)
+#define SPI_SPIBUF_RXEMPTY_MASK		(0x80000000u)
+
+
+#define SPI_SPIFLG_DLEN_ERR_MASK	(0x00000001u)
+#define SPI_SPIFLG_TIMEOUT_MASK		(0x00000002u)
+#define SPI_SPIFLG_PARERR_MASK		(0x00000004u)
+#define SPI_SPIFLG_DESYNC_MASK		(0x00000008u)
+#define SPI_SPIFLG_BITERR_MASK		(0x00000010u)
+#define SPI_SPIFLG_OVRRUN_MASK		(0x00000040u)
+#define SPI_SPIFLG_RX_INTR_MASK		(0x00000100u)
+#define SPI_SPIFLG_TX_INTR_MASK		(0x00000200u)
+#define SPI_SPIFLG_BUF_INIT_ACTIVE_MASK	(0x01000000u)
+#define SPI_SPIFLG_MASK			(SPI_SPIFLG_DLEN_ERR_MASK \
+		| SPI_SPIFLG_TIMEOUT_MASK | SPI_SPIFLG_PARERR_MASK \
+		| SPI_SPIFLG_DESYNC_MASK | SPI_SPIFLG_BITERR_MASK \
+		| SPI_SPIFLG_OVRRUN_MASK | SPI_SPIFLG_RX_INTR_MASK \
+		| SPI_SPIFLG_TX_INTR_MASK | SPI_SPIFLG_BUF_INIT_ACTIVE_MASK)
+
+#define SPI_SPIINT_DLEN_ERR_INTR	(0x00000001u)
+#define SPI_SPIINT_TIMEOUT_INTR		(0x00000002u)
+#define SPI_SPIINT_PARERR_INTR		(0x00000004u)
+#define SPI_SPIINT_DESYNC_INTR		(0x00000008u)
+#define SPI_SPIINT_BITERR_INTR		(0x00000010u)
+#define SPI_SPIINT_OVRRUN_INTR		(0x00000040u)
+#define SPI_SPIINT_RX_INTR		(0x00000100u)
+#define SPI_SPIINT_TX_INTR		(0x00000200u)
+#define SPI_SPIINT_DMA_REQ_EN		(0x00010000u)
+#define SPI_SPIINT_ENABLE_HIGHZ		(0x01000000u)
+
+/**< Error return coded */
+#define SPI_ERROR_BASE			(-30)
+#define SPI_OVERRUN_ERR			(SPI_ERROR_BASE-1)
+#define SPI_BIT_ERR			(SPI_ERROR_BASE-2)
+#define SPI_DESYNC_ERR			(SPI_ERROR_BASE-3)
+#define SPI_PARITY_ERR			(SPI_ERROR_BASE-4)
+#define SPI_TIMEOUT_ERR			(SPI_ERROR_BASE-5)
+#define SPI_TRANSMIT_FULL_ERR		(SPI_ERROR_BASE-6)
+#define SPI_POWERDOWN			(SPI_ERROR_BASE-7)
+#define SPI_DLEN_ERR			(SPI_ERROR_BASE-8)
+#define SPI_TX_INTR_ERR			(SPI_ERROR_BASE-9)
+#define SPI_BUF_INIT_ACTIVE_ERR		(SPI_ERROR_BASE-11)
+
+#define SPI_BYTELENGTH 8u
+
+/******************************************************************/
+
+enum spi_pin_op_mode {
+	SPI_OPMODE_3PIN,
+	SPI_OPMODE_SPISCS_4PIN,
+	SPI_OPMODE_SPIENA_4PIN,
+	SPI_OPMODE_5PIN,
+};
+
+struct davinci_spi_config_t {
+	/* SPIFMT */
+	u32	wdelay;
+	u32	odd_parity;
+	u32	parity_enable;
+	u32	wait_enable;
+	u32	lsb_first;
+	u32	timer_disable;
+	u32	clk_high;
+	u32	phase_in;
+	/* SPIGCR1 */
+	u32	clk_internal;
+	u32	loop_back;
+	/* SPIDAT1 */
+	u32	cs_hold;
+	/* SPIINTLVL1 */
+	u32	intr_level;
+	/* Others */
+	enum spi_pin_op_mode	pin_op_modes;
+	u32	poll_mode;
+};
+
+/* SPI Controller registers */
+
+#define SPIGCR0		0x00
+#define SPIGCR1		0x04
+#define SPIINT		0x08
+#define SPILVL		0x0c
+#define SPIFLG		0x10
+#define SPIPC0		0x14
+#define SPIPC1		0x18
+#define SPIPC2		0x1c
+#define SPIPC3		0x20
+#define SPIPC4		0x24
+#define SPIPC5		0x28
+#define SPIPC6		0x2c
+#define SPIPC7		0x30
+#define SPIPC8		0x34
+#define SPIDAT0		0x38
+#define SPIDAT1		0x3c
+#define SPIBUF		0x40
+#define SPIEMU		0x44
+#define SPIDELAY	0x48
+#define SPIDEF		0x4c
+#define SPIFMT0		0x50
+#define SPIFMT1		0x54
+#define SPIFMT2		0x58
+#define SPIFMT3		0x5c
+#define TGINTVEC0	0x60
+#define TGINTVEC1	0x64
+
+struct davinci_spi_slave {
+	u32	cmd_to_write;
+	u32	clk_ctrl_to_write;
+	u32	bytes_per_word;
+	u8	active_cs;
+};
+
+#define SPI_BUFSIZ	(SMP_CACHE_BYTES + 1)
+
+/* We have 2 DMA channels per CS, one for RX and one for TX */
+struct davinci_spi_dma {
+	int			dma_tx_channel;
+	int			dma_rx_channel;
+	int			dma_tx_sync_dev;
+	int			dma_rx_sync_dev;
+	enum dma_event_q	eventq;
+
+	struct completion	dma_tx_completion;
+	struct completion	dma_rx_completion;
+};
+
+/* SPI Controller driver's private data. */
+struct davinci_spi {
+	/* bitbang has to be first */
+	struct spi_bitbang	bitbang;
+
+	u8			version;
+	resource_size_t		pbase;
+	void __iomem		*base; /* virtual base */
+	size_t			region_size;
+	u32			irq;
+	struct completion	done;
+
+	const void		*tx;
+	void			*rx;
+	u8			*tmp_buf;
+	int			count;
+	struct davinci_spi_dma	*dma_channels;
+	struct davinci_spi_platform_data *pdata;
+
+	void			(*get_rx)(u32 rx_data, struct davinci_spi *);
+	u32			(*get_tx)(struct davinci_spi *);
+
+	struct davinci_spi_slave slave[DAVINCI_SPI_MAX_CHIPSELECT];
+};
Index: primus-kernel/include/linux/spi/mtd_spi_flash.h
===================================================================
--- /dev/null
+++ primus-kernel/include/linux/spi/mtd_spi_flash.h
@@ -0,0 +1,86 @@
+/*
+ * DaVinci SPI-EEPROM client driver header file
+ *
+ * Author: Steve Chen <schen@mvista.com>
+ *
+ * 2008 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#ifndef MTD_SPI_FLASH_H
+#define MTD_SPI_FLASH_H
+
+#include <linux/cache.h>
+/*
+ *  op-codes
+ */
+#define MTD_SPI_FLASH_WREN	0x06	/* write enable */
+#define MTD_SPI_FLASH_WRDIS	0x04	/* write disable */
+#define MTD_SPI_FLASH_WRSTAT	0x01	/* write status register */
+#define MTD_SPI_FLASH_WRITE	0x02	/* write/page program */
+
+#define MTD_SPI_FLASH_RDSTAT	0x05	/* read status register */
+#define MTD_SPI_FLASH_RD	0x03	/* read data */
+#define MTD_SPI_FLASH_FRD	0x0B	/* fast read */
+#define MTD_SPI_FLASH_FRDDO	0x3B	/* fast read dual output */
+
+#define MTD_SPI_FLASH_SECERA	0x20	/* sector erase */
+#define MTD_SPI_FLASH_BKERA	0xD8	/* block erase */
+#define MTD_SPI_FLASH_CHPERA	0xC7	/* chip erase */
+
+#define MTD_SPI_FLASH_PWRDN	0xB8	/* power down */
+#define MTD_SPI_FLASH_RELPWRDN	0xAB	/* release power down/ device id */
+
+#define MTD_SPI_FLASH_MFRID	0x90	/* manufacture ID */
+#define MTD_SPI_FLASH_JEDECID	0x9F	/* JEDEC ID */
+
+/*
+ *  Manufacture ID
+ */
+#define SPI_FLASH_MFR_WINBOND	0xEF
+
+/*
+ *  Device ID
+ */
+#define SPI_FLASH_W25X16	0x14
+#define SPI_FLASH_W25X32	0x15
+#define SPI_FLASH_W25X64	0x16
+
+/*
+ * Status register definitions
+ */
+#define SPI_FLASH_STAT_BUSY	0x1	/* read/write in progress */
+#define SPI_FLASH_STAT_WEL	0x2	/* Write Enable Latch */
+
+#define SPI_FLASH_BUFFER_SIZE 256
+#define SPI_FLASH_CMD_SIZE 	4
+
+#define MTD_SPI_FLASH_NAME "spi_flash"
+
+struct mtd_partition;
+
+struct mtd_spi_flash_info {
+	char *name;
+	unsigned int page_size;
+	unsigned int page_mask;
+	unsigned int sector_erase_size;
+	unsigned int block_erase_size;
+	unsigned long chip_sel;
+	unsigned int commit_delay;
+	struct spi_device *spi;
+	struct davinci_spi *spi_data;
+	void *controller_data;
+
+	struct mtd_info mtd;
+
+	struct mtd_partition *parts;
+	unsigned int nr_parts;
+
+	struct mutex lock;
+	char tx_buffer[SPI_FLASH_BUFFER_SIZE + SPI_FLASH_CMD_SIZE];
+	char rx_buffer[SPI_FLASH_BUFFER_SIZE + 1];
+};
+
+#endif	/* MTD_SPI_FLASH_H */
Index: primus-kernel/arch/arm/mach-davinci/omapl1x7.c
===================================================================
--- primus-kernel.orig/arch/arm/mach-davinci/omapl1x7.c
+++ primus-kernel/arch/arm/mach-davinci/omapl1x7.c
@@ -202,6 +202,18 @@ static struct clk aemif_clk = {
 	.lpsc = OMAPL1X7_LPSC_EMIF25,
 };
 
+static struct clk spi0_clk = {
+	.name = "SPI0CLK",
+	.parent = &pll1_sysclk2,
+	.lpsc = OMAPL1X7_LPSC_SPI0,
+};
+
+static struct clk spi1_clk = {
+	.name = "SPI1CLK",
+	.parent = &pll1_sysclk2,
+	.lpsc = OMAPL1X7_LPSC_SPI1,
+};
+
 static struct clk *omapl1x7_clks[] __initdata = {
 	&ref_clk,
 	&aux_clkin,
@@ -230,6 +242,8 @@ static struct clk *omapl1x7_clks[] __ini
 	&mmcsd_clk,
 	&emif3_clk,
 	&aemif_clk,
+	&spi0_clk,
+	&spi1_clk,
 	NULL,
 };
 
@@ -371,6 +385,17 @@ OMAPL1X7_MUX_CFG(OMAPL1X7,	EMB_D_14,	6, 
 OMAPL1X7_MUX_CFG(OMAPL1X7,	EMB_D_15,	7,   0,     15,   1,     false)
 OMAPL1X7_MUX_CFG(OMAPL1X7,	NEMB_WE_DQM_1,	7,   4,     15,   1,     false)
 OMAPL1X7_MUX_CFG(OMAPL1X7,	NEMB_WE_DQM_0,	7,   8,     15,   1,     false)
+OMAPL1X7_MUX_CFG(OMAPL1X7,	SPI0_SOMI_0,	7,   12,    15,   1,     false)
+OMAPL1X7_MUX_CFG(OMAPL1X7,	SPI0_SIMO_0,	7,   16,    15,   1,     false)
+OMAPL1X7_MUX_CFG(OMAPL1X7,	SPI0_CLK,	7,   20,    15,   1,     false)
+OMAPL1X7_MUX_CFG(OMAPL1X7,	NSPI0_ENA,	7,   24,    15,   1,     false)
+OMAPL1X7_MUX_CFG(OMAPL1X7,	NSPI0_SCS_0,	7,   28,    15,   1,     false)
+OMAPL1X7_MUX_CFG(OMAPL1X7,	SPI1_SOMI_0,	8,   0,     15,   1,     false)
+OMAPL1X7_MUX_CFG(OMAPL1X7,	SPI1_SIMO_0,	8,   4,     15,   1,     false)
+OMAPL1X7_MUX_CFG(OMAPL1X7,	SPI1_CLK,	8,   8,     15,   1,     false)
+OMAPL1X7_MUX_CFG(OMAPL1X7,	NSPI1_ENA,	8,   28,    15,   1,     false)
+OMAPL1X7_MUX_CFG(OMAPL1X7,	NSPI1_SCS_0,	9,   0,     15,   1,     false)
+OMAPL1X7_MUX_CFG(OMAPL1X7,	GPIO3_10,	11,  12,    15,   8,     false)
 };
 
 void __init omapl1x7_init(void)
Index: primus-kernel/drivers/mtd/devices/Makefile
===================================================================
--- primus-kernel.orig/drivers/mtd/devices/Makefile
+++ primus-kernel/drivers/mtd/devices/Makefile
@@ -17,3 +17,5 @@ obj-$(CONFIG_MTD_BLOCK2MTD)	+= block2mtd
 obj-$(CONFIG_MTD_DATAFLASH)	+= mtd_dataflash.o
 obj-$(CONFIG_MTD_M25P80)	+= m25p80.o
 obj-$(CONFIG_MTD_PS3VRAM)	+= ps3vram.o
+obj-$(CONFIG_DAVINCI_SPI_EEPROM)+= at25xxA_eeprom.o
+obj-$(CONFIG_MTD_SPI_FLASH)	+= spi_flash.o
Index: primus-kernel/arch/arm/mach-davinci/include/mach/mux.h
===================================================================
--- primus-kernel.orig/arch/arm/mach-davinci/include/mach/mux.h
+++ primus-kernel/arch/arm/mach-davinci/include/mach/mux.h
@@ -301,6 +301,21 @@ enum davinci_omapl1x7_index {
 	OMAPL1X7_EMB_D_15,
 	OMAPL1X7_NEMB_WE_DQM_1,
 	OMAPL1X7_NEMB_WE_DQM_0,
+
+	/* SPI0 function */
+	OMAPL1X7_SPI0_SOMI_0,
+	OMAPL1X7_SPI0_SIMO_0,
+	OMAPL1X7_SPI0_CLK,
+	OMAPL1X7_NSPI0_ENA,
+	OMAPL1X7_NSPI0_SCS_0,
+
+	/* SPI1 function */
+	OMAPL1X7_SPI1_SOMI_0,
+	OMAPL1X7_SPI1_SIMO_0,
+	OMAPL1X7_SPI1_CLK,
+	OMAPL1X7_NSPI1_ENA,
+	OMAPL1X7_NSPI1_SCS_0,
+	OMAPL1X7_GPIO3_10,
 };
 
 #ifdef CONFIG_DAVINCI_MUX
