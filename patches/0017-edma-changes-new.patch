Index: primus-kernel/arch/arm/mach-davinci/dma.c
===================================================================
--- primus-kernel.orig/arch/arm/mach-davinci/dma.c
+++ primus-kernel/arch/arm/mach-davinci/dma.c
@@ -95,11 +95,15 @@
 #define EDMA_CCSTAT	0x0640
 
 #define EDMA_M		0x1000	/* global channel registers */
+#define EDMA_ECR	0x1008
+#define EDMA_ECRH	0x100C
 #define EDMA_SHADOW0	0x2000	/* 4 regions shadowing global channels */
 #define EDMA_PARM	0x4000	/* 128 param entries */
 
 #define DAVINCI_DMA_3PCC_BASE	0x01C00000
 
+#define SZ_32K		0x00008000
+
 #define PARM_OFFSET(param_no)	(EDMA_PARM + ((param_no) << 5))
 
 #define edmacc_regs_base	IO_ADDRESS(DAVINCI_DMA_3PCC_BASE)
@@ -223,12 +227,37 @@ static struct resource edma_resources[] 
 	},
 };
 
+static struct resource edma_omapl1x7_resources[] = {
+	{
+		.start	= DAVINCI_DMA_3PCC_BASE,
+		.end	= DAVINCI_DMA_3PCC_BASE + SZ_32K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "edma_tc0",
+		.start	= 0x01C08000,
+		.end	= 0x01C08000 + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "edma_tc1",
+		.start	= 0x01C08400,
+		.end	= 0x01C08400 + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
 static struct platform_device edma_dev = {
 	.name		= "edma",
 	.id		= -1,
 	.dev.driver	= &edma_driver.driver,
+#ifdef CONFIG_ARCH_OMAPL1x7
+	.num_resources	= ARRAY_SIZE(edma_omapl1x7_resources),
+	.resource	= edma_omapl1x7_resources,
+#else
 	.num_resources	= ARRAY_SIZE(edma_resources),
 	.resource	= edma_resources,
+#endif
 };
 
 /*****************************************************************************/
@@ -262,6 +291,9 @@ static const s8 __initconst dma_chan_dm6
 static const s8 __initconst dma_chan_dm355_no_event[] = {
 	12, 13, 24, 56, 57, 58, 59, 60, 61, 62, 63, -1
 };
+static const s8 __initconst dma_chan_omapl1x7_no_event[] = {
+	20, 21, -1
+};
 
 static const int __initconst
 queue_tc_mapping[DAVINCI_EDMA_NUM_EVQUE + 1][2] = {
@@ -338,6 +370,7 @@ static irqreturn_t dma_irq_handler(int i
 	unsigned int cnt = 0;
 
 	dev_dbg(&edma_dev.dev, "dma_irq_handler\n");
+	printk("dma_irq_handler\n");
 
 	if ((edma_shadow0_read_array(SH_IPR, 0) == 0)
 	    && (edma_shadow0_read_array(SH_IPR, 1) == 0))
@@ -475,6 +508,22 @@ static irqreturn_t dma_tc1err_handler(in
 	return IRQ_HANDLED;
 }
 
+/*
+ * edma_clear_event - clear an outstanding event on the DMA channel
+ * Arguments:
+ *      lch - logical channel number
+ */
+void edma_clear_event(int lch)
+{
+	if (lch < 0 || lch >= DAVINCI_EDMA_NUM_DMACH)
+		return;
+	if (lch < 32)
+		edma_write(EDMA_ECR, 1 << lch);
+	else
+		edma_write(EDMA_ECRH, 1 << (lch - 32));
+}
+EXPORT_SYMBOL(edma_clear_event);
+
 /******************************************************************************
  *
  * DMA initialisation on davinci
@@ -485,6 +534,9 @@ static int __init davinci_dma_init(void)
 	int i;
 	int status;
 	const s8 *noevent;
+	unsigned int cc_reg0_int = IRQ_CCINT0, cc_error_int = IRQ_CCERRINT;
+	unsigned int tc0_error_int = IRQ_TCERRINT0;
+	unsigned int tc1_error_int = IRQ_TCERRINT;
 
 	platform_driver_register(&edma_driver);
 	platform_device_register(&edma_dev);
@@ -505,6 +557,8 @@ static int __init davinci_dma_init(void)
 		noevent = dma_chan_dm355_no_event;
 	} else if (cpu_is_davinci_dm644x()) {
 		noevent = dma_chan_dm644x_no_event;
+	} else if (cpu_is_omapl1x7()) {
+		noevent = dma_chan_omapl1x7_no_event;
 	} else {
 		/* alloc_channel(EDMA_CHANNEL_ANY) fails */
 		noevent = NULL;
@@ -515,13 +569,20 @@ static int __init davinci_dma_init(void)
 			set_bit(*noevent++, edma_noevent);
 	}
 
-	status = request_irq(IRQ_CCINT0, dma_irq_handler, 0, "edma", NULL);
+	if (cpu_is_omapl1x7()) {
+		cc_reg0_int  = IRQ_OMAPL1X7_CCINT0;
+		cc_error_int = IRQ_OMAPL1X7_CCERRINT;
+		tc0_error_int = IRQ_OMAPL1X7_TCERRINT0;
+		tc1_error_int = IRQ_OMAPL1X7_TCERRINT1;
+	}
+
+	status = request_irq(cc_reg0_int, dma_irq_handler, 0, "edma", NULL);
 	if (status < 0) {
 		dev_dbg(&edma_dev.dev, "request_irq %d failed --> %d\n",
 			IRQ_CCINT0, status);
 		return status;
 	}
-	status = request_irq(IRQ_CCERRINT, dma_ccerr_handler, 0,
+	status = request_irq(cc_error_int, dma_ccerr_handler, 0,
 				"edma_error", NULL);
 	if (status < 0) {
 		dev_dbg(&edma_dev.dev, "request_irq %d failed --> %d\n",
@@ -530,14 +591,14 @@ static int __init davinci_dma_init(void)
 	}
 
 	if (tc_errs_handled) {
-		status = request_irq(IRQ_TCERRINT0, dma_tc0err_handler, 0,
+		status = request_irq(tc0_error_int, dma_tc0err_handler, 0,
 					"edma_tc0", NULL);
 		if (status < 0) {
 			dev_dbg(&edma_dev.dev, "request_irq %d failed --> %d\n",
 				IRQ_TCERRINT0, status);
 			return status;
 		}
-		status = request_irq(IRQ_TCERRINT, dma_tc1err_handler, 0,
+		status = request_irq(tc1_error_int, dma_tc1err_handler, 0,
 					"edma_tc1", NULL);
 		if (status < 0) {
 			dev_dbg(&edma_dev.dev, "request_irq %d --> %d\n",
@@ -647,7 +708,6 @@ int edma_alloc_channel(int channel,
 }
 EXPORT_SYMBOL(edma_alloc_channel);
 
-
 /**
  * edma_free_channel - deallocate DMA channel
  * @channel: dma channel returned from edma_alloc_channel()
Index: primus-kernel/arch/arm/mach-davinci/include/mach/edma.h
===================================================================
--- primus-kernel.orig/arch/arm/mach-davinci/include/mach/edma.h
+++ primus-kernel/arch/arm/mach-davinci/include/mach/edma.h
@@ -217,6 +217,7 @@ void edma_stop(unsigned channel);
 void edma_clean_channel(unsigned channel);
 void edma_pause(unsigned channel);
 void edma_resume(unsigned channel);
+void edma_clear_event(int lch);
 
 /* UNRELATED TO DMA */
 int davinci_alloc_iram(unsigned size);
Index: primus-kernel/arch/arm/mach-davinci/omapl1x7.c
===================================================================
--- primus-kernel.orig/arch/arm/mach-davinci/omapl1x7.c
+++ primus-kernel/arch/arm/mach-davinci/omapl1x7.c
@@ -163,6 +163,27 @@ static struct clk gpio_clk = {
 	.lpsc = OMAPL1X7_LPSC_GPIO,
 };
 
+static struct clk edma_cc0_clk = {
+	.name = "edma_cc0",
+	.parent = &pll1_sysclk2,
+	.lpsc = OMAPL1X7_LPSC_TPCC,
+	.flags = CLK_PSC | ALWAYS_ENABLED,
+};
+
+static struct clk edma_tc0_clk = {
+	.name = "edma_tc0",
+	.parent = &pll1_sysclk2,
+	.lpsc = OMAPL1X7_LPSC_TPTC0,
+	.flags = ALWAYS_ENABLED,
+};
+
+static struct clk edma_tc1_clk = {
+	.name = "edma_tc1",
+	.parent = &pll1_sysclk2,
+	.lpsc = OMAPL1X7_LPSC_TPTC1,
+	.flags = ALWAYS_ENABLED,
+};
+
 static struct clk *omapl1x7_clks[] __initdata = {
 	&ref_clk,
 	&aux_clkin,
@@ -185,6 +206,9 @@ static struct clk *omapl1x7_clks[] __ini
 	&i2c_clk,
 	&emac_clk,
 	&gpio_clk,
+	&edma_cc0_clk,
+	&edma_tc0_clk,
+	&edma_tc1_clk,
 	NULL,
 };
 
