Index: primus-kernel/arch/arm/mach-davinci/time.c
===================================================================
--- primus-kernel.orig/arch/arm/mach-davinci/time.c
+++ primus-kernel/arch/arm/mach-davinci/time.c
@@ -19,7 +19,7 @@
 #include <linux/clk.h>
 #include <linux/err.h>
 
-#include <mach/hardware.h>
+#include <mach/omapl1x7.h>
 #include <asm/system.h>
 #include <asm/irq.h>
 #include <asm/mach/irq.h>
@@ -35,6 +35,8 @@ static unsigned int davinci_clock_tick_r
 #define DAVINCI_TIMER0_BASE (IO_PHYS + 0x21400)
 #define DAVINCI_TIMER1_BASE (IO_PHYS + 0x21800)
 #define DAVINCI_WDOG_BASE   (IO_PHYS + 0x21C00)
+#define OMAPL1X7_TIMER64P0_BASE		0x01C20000
+#define OMAPL1X7_TIMER64P1_BASE		0x01C21000
 
 enum {
 	T0_BOT = 0, T0_TOP, T1_BOT, T1_TOP, NUM_TIMERS,
@@ -45,13 +47,23 @@ enum {
 #define IS_TIMER_TOP(id) ((id & 0x1))
 #define IS_TIMER_BOT(id) (!IS_TIMER_TOP(id))
 
-static int timer_irqs[NUM_TIMERS] = {
+static int default_timer_irqs[NUM_TIMERS] = {
 	IRQ_TINT0_TINT12,
 	IRQ_TINT0_TINT34,
 	IRQ_TINT1_TINT12,
 	IRQ_TINT1_TINT34,
 };
 
+static int omapl1x7_timer_irqs[NUM_TIMERS] = {
+	IRQ_OMAPL1X7_TINT12_0,
+	IRQ_OMAPL1X7_TINT34_0,
+	IRQ_OMAPL1X7_TINT12_1,
+	IRQ_OMAPL1X7_TINT34_1
+};
+
+static int tid_system;
+static int tid_freerun;
+
 /*
  * This driver configures the 2 64-bit count-up timers as 4 independent
  * 32-bit count-up timers used as follows:
@@ -110,7 +122,6 @@ struct timer_s {
 	unsigned long enamode_shift;
 	struct irqaction irqaction;
 };
-static struct timer_s timers[];
 
 /* values for 'opts' field of struct timer_s */
 #define TIMER_OPTS_DISABLED   0x00
@@ -159,33 +170,33 @@ static irqreturn_t freerun_interrupt(int
 	return IRQ_HANDLED;
 }
 
-static struct timer_s timers[] = {
-	[TID_CLOCKEVENT] = {
-		.name      = "clockevent",
-		.opts      = TIMER_OPTS_DISABLED,
-		.irqaction = {
-			.flags   = IRQF_DISABLED | IRQF_TIMER,
-			.handler = timer_interrupt,
-		}
-	},
-	[TID_CLOCKSOURCE] = {
-		.name       = "free-run counter",
-		.period     = ~0,
-		.opts       = TIMER_OPTS_PERIODIC,
-		.irqaction = {
-			.flags   = IRQF_DISABLED | IRQF_TIMER,
-			.handler = freerun_interrupt,
-		}
-	},
+static struct timer_s davinci_system_timer = {
+	.name      = "clockevent",
+	.opts      = TIMER_OPTS_DISABLED,
+	.irqaction = {
+		.flags   = IRQF_DISABLED | IRQF_TIMER,
+		.handler = timer_interrupt,
+	}
 };
 
-static void __init timer_init(void)
+static struct timer_s davinci_freerun_timer = {
+	.name       = "free-run counter",
+	.period     = ~0,
+	.opts       = TIMER_OPTS_PERIODIC,
+	.irqaction = {
+		.flags   = IRQF_DISABLED | IRQF_TIMER,
+		.handler = freerun_interrupt,
+	}
+};
+
+static struct timer_s *timers[NUM_TIMERS];
+
+static void __init timer_init(int num_timers, u32 *phys_bases, int *timer_irqs)
 {
-	u32 phys_bases[] = {DAVINCI_TIMER0_BASE, DAVINCI_TIMER1_BASE};
 	int i;
 
 	/* Global init of each 64-bit timer as a whole */
-	for(i=0; i<2; i++) {
+	for(i=0; i<num_timers; i++) {
 		u32 tgcr;
 		void __iomem *base = IO_ADDRESS(phys_bases[i]);
 
@@ -211,14 +222,13 @@ static void __init timer_init(void)
 	}
 
 	/* Init of each timer as a 32-bit timer */
-	for (i=0; i< ARRAY_SIZE(timers); i++) {
-		struct timer_s *t = &timers[i];
+	for (i=0; i< NUM_TIMERS; i++) {
+		struct timer_s *t = timers[i];
 		u32 phys_base;
 
-		if (t->name) {
+		if (t && t->name) {
 			t->id = i;
-			phys_base = (IS_TIMER1(t->id) ?
-			       DAVINCI_TIMER1_BASE : DAVINCI_TIMER0_BASE);
+			phys_base = phys_bases[i >> 1];
 			t->base = IO_ADDRESS(phys_base);
 
 			if (IS_TIMER_BOT(t->id)) {
@@ -238,7 +248,7 @@ static void __init timer_init(void)
 				setup_irq(timer_irqs[t->id], &t->irqaction);
 			}
 
-			timer32_config(&timers[i]);
+			timer32_config(timers[i]);
 		}
 	}
 }
@@ -248,7 +258,12 @@ static void __init timer_init(void)
  */
 static cycle_t read_cycles(void)
 {
-	struct timer_s *t = &timers[TID_CLOCKSOURCE];
+	struct timer_s *t;
+
+	if (tid_freerun == -1)
+		t = timers[tid_system];
+	else
+		t = timers[tid_freerun];
 
 	return (cycles_t)timer32_read(t);
 }
@@ -268,7 +283,7 @@ static struct clocksource clocksource_da
 static int davinci_set_next_event(unsigned long cycles,
 				  struct clock_event_device *evt)
 {
-	struct timer_s *t = &timers[TID_CLOCKEVENT];
+	struct timer_s *t = timers[tid_system];
 
 	t->period = cycles;
 	timer32_config(t);
@@ -278,7 +293,7 @@ static int davinci_set_next_event(unsign
 static void davinci_set_mode(enum clock_event_mode mode,
 			     struct clock_event_device *evt)
 {
-	struct timer_s *t = &timers[TID_CLOCKEVENT];
+	struct timer_s *t = timers[tid_system];
 
 	switch (mode) {
 	case CLOCK_EVT_MODE_PERIODIC:
@@ -306,17 +321,20 @@ static struct clock_event_device clockev
 	.set_mode	= davinci_set_mode,
 };
 
+static u32 davinci_bases[] = { DAVINCI_TIMER0_BASE, DAVINCI_TIMER1_BASE };
+static u32 omapl1x7_bases[] = { OMAPL1X7_TIMER64P0_BASE,
+				OMAPL1X7_TIMER64P1_BASE };
 
 static void __init davinci_timer_init(void)
 {
+	int num_timers;
+	int *timer_irqs;
+	u32 *bases;
 	struct clk *timer_clk, *wd_clk;
 
 	static char err[] __initdata = KERN_ERR
 		"%s: can't register clocksource!\n";
 
-	/* init timer hw */
-	timer_init();
-
 	timer_clk = clk_get(NULL, "timer0");
 	BUG_ON(IS_ERR(timer_clk));
 	clk_enable(timer_clk);
@@ -327,6 +345,67 @@ static void __init davinci_timer_init(vo
 		clk_enable(wd_clk);
 	}
 
+	if (cpu_is_omapl1x7()) {
+		wd_clk = clk_get(NULL, "watchdog");
+		BUG_ON(IS_ERR(wd_clk));
+		clk_enable(wd_clk);
+	}
+
+	num_timers = 2;
+	bases = davinci_bases;
+	timer_irqs = default_timer_irqs;
+	if (cpu_is_omapl1x7()) {
+		/*
+		 * Configure the 2 64-bit timer as 4 32-bit timers with
+		 * following assignments.
+		 *
+		 * T0_BOT: Timer 0, bottom: free run counter and system clock.
+		 * T0_TOP: Timer 0, top:  Reserve for DSP
+		 * T1_BOT: Timer 1, watch dog timer.
+		 */
+		tid_system = T0_BOT;
+
+		/* timer interrupt using compare reg so free-run not needed */
+		bases = omapl1x7_bases;
+		timer_irqs = omapl1x7_timer_irqs;
+		num_timers = 2;
+		tid_freerun = T0_TOP;
+	} else if (cpu_is_davinci_dm646x()) {
+		/*
+		 * Configure the 2 64-bit timer as 4 32-bit timers with
+		 * following assignments.
+		 *
+		 * T0_BOT: Timer 0, bottom:  AV Sync
+		 * T0_TOP: Timer 0, top:  free-running counter,
+		 *                        used for cycle counter
+		 * T1_BOT: Timer 1, bottom:  reserved for DSP
+		 * T1_TOP: Timer 1, top   :  Linux system tick
+		 */
+		tid_system = T1_TOP;
+		tid_freerun = T0_TOP;
+	} else if (cpu_is_davinci_dm644x()) {
+		/*
+		 * Configure the 2 64-bit timer as 4 32-bit timers with
+		 * following assignments.
+		 *
+		 * T0_BOT: Timer 0, bottom:  clockevent source for hrtimers
+		 * T0_TOP: Timer 0, top   :  clocksource for generic timekeeping
+		 * T1_BOT: Timer 1, bottom:  (used by DSP in TI DSPLink code)
+		 * T1_TOP: Timer 1, top   :  <unused>
+		 */
+		tid_system = T0_BOT;
+		tid_freerun = T0_TOP;
+	}
+
+	if (tid_system != -1)
+		timers[tid_system] = &davinci_system_timer;
+
+	if (tid_freerun != -1)
+		timers[tid_freerun] = &davinci_freerun_timer;
+
+	/* init timer hw */
+	timer_init(num_timers, bases, timer_irqs);
+	
 	davinci_clock_tick_rate = clk_get_rate(timer_clk);
 	clk_put(timer_clk);
 
